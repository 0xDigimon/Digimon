<!doctype html>
<html lang="en-us">
  <head>
    <title>Web Application Hacker‚Äôs Methodology // Abdelrhman Allam</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.101.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Abdelrhman Allam" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sl4x0.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Web Application Hacker‚Äôs Methodology"/>
<meta name="twitter:description" content="Chapter 21: A Web Application Hacker‚Äôs Methodology by @sl4x0 ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖInformation gathered in one stage may enable you to return to an earlier stage and formulate more focused attacks. For example, an access control bug that enables you to obtain a listing of all users may enable you to perform a more effective password-guessing attack against the authentication function. Discovering a key vulnerability in one area of the application may enable you to shortcut some of the work in other areas."/>

    <meta property="og:title" content="Web Application Hacker‚Äôs Methodology" />
<meta property="og:description" content="Chapter 21: A Web Application Hacker‚Äôs Methodology by @sl4x0 ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖInformation gathered in one stage may enable you to return to an earlier stage and formulate more focused attacks. For example, an access control bug that enables you to obtain a listing of all users may enable you to perform a more effective password-guessing attack against the authentication function. Discovering a key vulnerability in one area of the application may enable you to shortcut some of the work in other areas." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sl4x0.github.io/books/wahh-methdology/" /><meta property="article:section" content="books" />
<meta property="article:published_time" content="2022-09-26T23:48:05+00:00" />
<meta property="article:modified_time" content="2022-09-26T23:48:05+00:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://sl4x0.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="Abdelrhman Allam" /></a>
      <h1>Abdelrhman Allam</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/about/">About</a>
             // 
          
          <a class="app-header-menu-item" href="/">Home</a>
             // 
          
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>Security Researcher üêõ</p>
      <div class="app-header-social">
        
          <a href="https://github.com/sl4x0" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
          <a href="https://twitter.com/sl4x0" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>My Twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg>
          </a>
        
          <a href="https://linkedin.com/in/sl4x0" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-linkedin">
  <title>My Twitter</title>
  <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Web Application Hacker‚Äôs Methodology</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 26, 2022
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          85 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://sl4x0.github.io/tags/method/">method</a>
              <a class="tag" href="https://sl4x0.github.io/tags/bug-bounty/">bug-bounty</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="chapter-21-a-web-application-hackers-methodology-by-sl4x0">Chapter 21: A Web Application Hacker‚Äôs Methodology by @sl4x0</h1>
<pre><code>                                               ÿ®ÿ≥ŸÖ ÿßŸÑŸÑŸá ÿßŸÑÿ±ÿ≠ŸÖŸÜ ÿßŸÑÿ±ÿ≠ŸäŸÖ
</code></pre>
<ul>
<li>Information gathered in one stage may enable you to return to an earlier
stage and formulate more focused attacks. For example, an access control
bug that enables you to obtain a <strong>listing of all users</strong> may enable you to perform a more effective <strong>password-guessing</strong> attack against the authentication function.</li>
<li>Discovering a key vulnerability in one area of the application may enable
you to shortcut some of the work in other areas. For example, a fi le disclosure
vulnerability may enable to you perform a <strong>code review of key application
functions</strong> rather than probing them in a solely black-box manner.</li>
<li>The results of your testing in some areas may highlight patterns of recurring vulnerabilities that you can immediately probe for in other areas.
For example, a generic defect in the application‚Äôs input validation filters
may enable you to quickly find a <strong>bypass</strong> of its defenses against several
different categories of attack.</li>
</ul>
<h1 id="general-guidelines">General Guidelines</h1>
<ul>
<li>
<p>Remember that several characters have special meaning in different parts
of the HTTP request. When you are modifying the data within requests,
you should <strong>URL-encode</strong> these characters to ensure that they are interpreted
in the way you intend:</p>
</li>
<li>
<p>&amp; is used to <strong>separate parameters</strong> in the URL query string and message
body. To insert a literal &amp; character, you should encode this as %26.</p>
</li>
<li>
<p>= is used to <strong>separate the name and value</strong> of each parameter in the URL
query string and message body. To insert a literal = character, you
should encode this as %3d.</p>
</li>
<li>
<p>? is used to mark the beginning of the <strong>URL query string</strong>. To insert a
literal ? character, you should encode this as %3f.</p>
</li>
<li>
<p>A space is used to mark <strong>the end of the URL in the first line of requests</strong>
and can indicate the end of a cookie value in the Cookie header. To
insert a literal space, you should encode this as %20 or +.</p>
</li>
<li>
<p>Because + represents an encoded space, to insert a <strong>literal +</strong> character,
you should encode this as %2b.</p>
</li>
<li>
<p>; is used to separate individual cookies in the Cookie header. To insert
a <strong>literal ;</strong> character, you should encode this as %3b.</p>
</li>
<li>
<h1 id="is-used-to-mark-the-fragment-identifier-within-the-url-if-you-enter-this-character-into-the-url-within-your-browser-it-effectively-truncates-the-url-that-is-sent-to-the-server-to-insert-a-literal--character-you-should-encode-this-as-23">is used to mark the <strong>fragment identifier within the URL</strong>. If you enter this character into the URL within your browser, it effectively truncates the URL that is sent to the server. To insert a literal # character, you should encode this as %23.</h1>
</li>
<li>
<p>% is used as the <strong>prefix in the URL-encoding scheme</strong>. To insert a literal
% character, you should encode this as %25.</p>
</li>
<li>
<p>Any nonprinting characters such as null bytes and newlines must, of
course, be URL-encoded using their ASCII character code ‚Äî in this case, as <strong>%00</strong> and <strong>%0a</strong>, respectively.</p>
</li>
<li>
<p>Furthermore, note that entering URL-encoded data into a form usually causes your browser to perform another layer of encoding. For example, submitting %00 in a form will probably result in a value of %2500 being sent to the server. For this reason it is normally best to observe the <strong>final request within an intercepting proxy.</strong></p>
</li>
<li>
<p>Many tests for common web application vulnerabilities involve sending
various crafted input strings and monitoring the application‚Äôs responses
for anomalies, which indicate that a vulnerability is present. In any case where specific crafted input results in behavior associated with a vulnerability (such as a particular
error message), you should <strong>double-check</strong> whether submitting benign
input in the relevant parameter also causes the same behavior. If it does,
your tentative finding is probably a false positive.</p>
</li>
<li>
<p>Applications typically accumulate an amount of state from previous requests,
which affects how they respond to further requests. To do so, it is usually sufficient to begin
a <strong>fresh session with a new browser process</strong>, navigate to the location of the
observed anomaly using only benign requests, and then resubmit your
crafted input. Or you can user Burp Repeater.</p>
</li>
<li>
<p>Some applications use a <strong>load-balanced configuration</strong> in which consecutive HTTP requests may be handled by different back-end servers at the
web, presentation, data, or other tiers. Different servers may have small
differences in configuration that affect your results. To isolate the effects of particular actions, it may be necessary to perform <strong>several identical requests in succession</strong>, testing the result of
each until your request is handled by the relevant server.</p>
</li>
</ul>
<hr>
<h1 id="1-map-the-applications-content"><code>1 Map the Application‚Äôs Content</code></h1>
<h2 id="11-explore-visible-content">1.1 Explore Visible Content</h2>
<p>1.1.1 Both <code>Burp</code> and <code>WebScarab</code> can be used to passively spider the site
by monitoring and parsing web content processed by the proxy.</p>
<p>1.1.2 If you find it useful, configure your browser to use an extension such
as <code>IEWatch</code> to monitor and analyze the HTTP and HTML content being
processed by the browser.</p>
<p>1.1.3 Browse the entire application in the normal way, visiting <code>every link</code> and
<code>URL</code>, submitting <code>every form</code>, and proceeding through all <code>multistep functions</code> to completion. Try browsing with <code>JavaScript</code> enabled and disabled, and with <code>cookies</code> enabled and disabled.</p>
<p>1.1.4 Make an <code>Account</code> to test Protected Functions</p>
<p>1.1.5 As you browse, monitor the requests and responses passing through
your intercepting proxy to gain an <code>understanding of the kinds of data being submitted</code><strong>.</strong></p>
<p>1.1.6 From the spider results, establish where each item was discovered (for example, in Burp Spider, check the <code>Linked From details</code>). Access each item using your browser so that the spider parses the response from the server to identify any further content.</p>
<p>1.1.7 Before doing an <code>automated crawl</code>, first identify any URLs that are dangerous or likely to
break the application session, and then configure the spider to exclude these from its scope.</p>
<h2 id="12-consult-public-resources">1.2 Consult Public Resources</h2>
<p>1.2.1 Use the <code>Wayback Machine</code> to identify the indexed content</p>
<p>1.2.2 Use <code>Google Dorking</code> to discover more content</p>
<p>1.2.3 Review any <code>published WSDL</code> fi les to generate a list of function names
and parameter values potentially employed by the application.</p>
<h2 id="13-discover-hidden-content">1.3 Discover Hidden Content</h2>
<p>1.3.1 Make some manual requests for known <code>valid and invalid resources</code>,
and compare the server‚Äôs responses to establish an easy way to identify
when an item does not exist.</p>
<p>1.3.2 Try to understand the naming conventions used by application developers. For example, if
there are pages called <code>AddDocument.jsp</code> and <code>ViewDocument.jsp</code>, there
may also be pages called <code>EditDocument.jsp</code> and <code>RemoveDocument.jsp</code></p>
<p>1.3.3 Review the <code>client side code</code> and HTML comments</p>
<p>1.3.4 Using the automation techniques described in <code>Chapter 14</code>, make large
numbers of requests based on your directory, filename, and file extension
lists.</p>
<p>1.3.5 Perform these <code>content-discovery</code> exercises recursively, using new enumerated content and patterns as the basis for further user-directed spidering and further automated discovery.</p>
<h2 id="14-discover-default-content">1.4 Discover Default Content</h2>
<p>1.4.1 Run <code>Nikto</code> against the web server to detect any default or well-known
content that is present. For example, you can use the <code>‚Äìroot</code> option to specify a directory
to check for default content, or <code>-404</code> to specify a string that identifies a
custom File Not Found page.</p>
<p>1.4.2 Verify any potentially interesting findings <code>manually</code> to eliminate any
false positives within the results.</p>
<p>1.4.3 Request the server‚Äôs <code>root directory</code>, specifying the IP address in the
Host header, and determine if the application responds with any different content. If so, run a <code>Nikto</code> scan against the IP address as well as
the server name.</p>
<p>1.4.4 Make a request to the server‚Äôs root directory, specifying a range of
<code>User-Agent headers</code>, as shown at <code>www.useragentstring.com/pages/useragentstring.php</code>.</p>
<h2 id="15-enumerate-identifier-specified-functions">1.5 Enumerate Identifier-Specified Functions</h2>
<p>1.5.1 Identify any instances where specific application functions are accessed by
<code>passing an identifier</code> of the function in a request parameter (for example,
<code>/admin.jsp?action=editUser</code> or <code>/main.php?func=A21</code>).</p>
<p>1.5.2 Apply the <code>content discovery</code> techniques used in step 1.3 to the mechanism
being used to access individual functions.</p>
<p>1.5.3 If applicable, <code>compile a map of application content based on functional paths</code>,
rather than URLs, showing all the enumerated functions and the logical
paths and dependencies between them.</p>
<h2 id="16-test-for-debug-parameters">1.6 Test for Debug Parameters</h2>
<p>1.6.1 Choose one or more application pages or functions where hidden debug
parameters (such as <code>debug=true</code>) may be implemented. These are most
likely to appear in key functionality such as login, search, and file upload
or download.</p>
<p>1.6.2 Use listings of common debug parameter names (such as debug, test, hide, and source) and common values (such as true, yes, on, and 1). Iterate through all permutations of these, submitting each name/value pair to each targeted function. For POST requests, supply the parameter
in both the <code>URL query string</code> and the <code>request body</code>. Use the techniques
described in Chapter 14 to automate this exercise. For example, you
can use the cluster bomb attack type in Burp Intruder to combine all
permutations of <code>two payload lists</code>.</p>
<p>1.6.3 Review the application‚Äôs responses for any <code>anomalies</code> that may indicate
that the added parameter has had an effect on the application‚Äôs processing.</p>
<hr>
<h1 id="2-analyze-the-application"><code>2 Analyze the Application</code></h1>
<h2 id="21-identify-functionality">2.1 Identify Functionality</h2>
<p>2.1.1 Identify the core functionality that the application was <code>created for</code> and
the actions that each function is designed to perform when used as intended.</p>
<p>2.1.2  Identify the core <code>security mechanisms</code> employed by the application and
how they work. In particular, understand the key mechanisms that handle authentication, session management, and access control, and the functions that support them, such as user registration and account recovery.</p>
<p>2.1.3 Identify all the more <code>peripheral functions</code> and behavior, such as the use
of redirects, off-site links, error messages, and administrative and logging functions.</p>
<p>2.1.4 Identify any functionality that <code>diverges from the standard GUI appearance</code>, parameter naming, or navigation mechanism used elsewhere in the application, and single it out for in-depth testing</p>
<h2 id="22-identify-data-entry-points">2.2 Identify Data Entry Points</h2>
<p>2.2.1 Identify all the different entry points that exist for introducing user
input into the application‚Äôs processing, including URLs, query string
parameters, POST data, cookies, and other HTTP headers processed by
the application.</p>
<p>2.2.2 Examine any <code>customized data transmission or encoding mechanisms</code>
used by the application, such as a nonstandard query string format.
Understand whether the data being submitted encapsulates parameter
names and values, or whether an alternative means of representation
is being used.</p>
<p>2.2.3 Identify any <code>out-of-band channels</code> via which user-controllable or other
third-party data is being introduced into the application‚Äôs processing. An example is a web mail application that processes and renders messages received via <code>SMTP</code>.</p>
<h2 id="23-identify-the-technologies-used">2.3 Identify the Technologies Used</h2>
<p>2.3.1 Identify each of the different technologies used on the client side, such as
forms, scripts, cookies, Java applets, ActiveX controls, and Flash objects</p>
<p>2.3.2 As far as possible, establish which technologies are being used on the
<code>server side</code>, including scripting languages, application platforms, and
interaction with back-end components such as databases and e-mail systems.</p>
<p>2.3.3 Check the HTTP <code>Server</code> header returned in application responses, and
also check for any other software identifiers contained within custom
HTTP headers or HTML source code comments.</p>
<p>2.3.4 Run the <code>Httprint</code> tool to fingerprint the web server.</p>
<p>2.3.5 Review the results of your content-mapping exercises to identify any
interesting-looking file extensions, directories, or other URL subsequences that may provide clues about the technologies in use on the server.</p>
<p>2.3.6 Identify any interesting-looking script names and query string parameters
that may belong to third-party code components. Search for these on
Google using the <code>inurl:</code> qualifier to find any other applications using
the same scripts and parameters and that therefore may be using the same third-party components.</p>
<h2 id="24-map-the-attack-surface">2.4 Map the Attack Surface</h2>
<p>2.4.1 Try to ascertain the likely internal structure and functionality of the
server-side application and the mechanisms it uses behind the scenes
to deliver the behavior that is visible from the client perspective. For
example, a function to <code>retrieve customer orders is likely to be interacting with a database.</code></p>
<p>2.4.2 For each item of functionality, identify the kinds of common vulnerabilities
that are often associated with it. For example, file upload functions may
be vulnerable to <code>path traversal</code>, inter-user messaging may be vulnerable
to XSS, and Contact Us functions may be vulnerable to SMTP injection.</p>
<p>2.4.3 Formulate a plan of attack, prioritizing the most interesting-looking
functionality and the most serious of the potential vulnerabilities associated with it.</p>
<hr>
<h1 id="3-test-client-side-controls"><code>3 Test Client-Side Controls</code></h1>
<h2 id="31-test-transmission-of-data-via-the-client">3.1 Test Transmission of Data Via the Client</h2>
<p>3.1.1 Locate all instances within the application where <code>hidden form fields</code>,
cookies, and URL parameters are apparently being used to transmit
data via the client.</p>
<p>3.1.2 Attempt to determine the purpose that the item plays in the application‚Äôs logic, based on the context in which it appears and on its name and value.</p>
<p>3.1.3 Modify the item‚Äôs value in ways that are relevant to its role in the
application‚Äôs functionality. Determine whether the application processes arbitrary values submitted in the field and whether this fact can be exploited to interfere with the application‚Äôs logic or subvert
any security controls.</p>
<p>3.1.4 If the application transmits opaque data via the client, you can attack this
in various ways. If the item is obfuscated, you may be able to decipher
the obfuscation algorithm and therefore submit arbitrary data within the
opaque item. Even if it is securely encrypted, you may be able to replay
the item in other contexts to interfere with the application‚Äôs logic.</p>
<p>3.1.5 If the application uses the ASP.NET <code>ViewState</code>, test to confirm whether
this can be tampered with or whether it contains any sensitive information. Note that the <code>ViewState</code> may be used differently on different application pages.</p>
<p>3.1.5.1 Use the <code>ViewState analyzer</code> in Burp Suite to confirm whether the <code>EnableViewStateMac</code> option has been enabled, meaning that the <code>ViewState‚Äôs contents</code> cannot be modified.
3.1.5.2 Review the decoded <code>ViewState</code> to identify any sensitive data it contains.
3.1.5.3 Modify one of the decoded parameter values and reencode and submit the <code>ViewState.</code> If the application accepts the modified value, you should treat the <code>ViewState</code> as an input channel for introducing arbitrary data into the application‚Äôs processing.
Perform the same testing on the data it contains as you would for any other request parameters.</p>
<h2 id="32-test-client-side-controls-over-user-input">3.2 Test Client-Side Controls Over User Input</h2>
<p>3.2.1 Identify any cases where <code>client-side controls</code> such as length limits and
JavaScript checks are used to validate user input before it is submitted  to the server. These controls can be bypassed easily, because you can  send arbitrary requests to the server. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">form</span> <span style="color:#a6e22e">action</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùorder.asp‚Äù</span> <span style="color:#a6e22e">onsubmit</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùreturn</span> <span style="color:#a6e22e">Validate</span><span style="color:#960050;background-color:#1e0010">(</span><span style="color:#a6e22e">this</span><span style="color:#960050;background-color:#1e0010">)‚Äù</span>&gt;
</span></span><span style="display:flex;"><span>&lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">maxlength</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äù3‚Äù</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùquantity‚Äù</span>&gt;
</span></span></code></pre></div><p>3.2.2 Test each <code>affected input field</code> in turn by submitting input that would
ordinarily be blocked by the client-side controls to verify whether these are replicated on the server.</p>
<p>3.2.3 The ability to bypass client-side validation does not necessarily represent
any vulnerability. Nevertheless, you should review closely what validation is being performed. Confirm whether the application is relying on the client-side controls to protect itself from malformed input. Also confirm whether any exploitable conditions exist that can be triggered by such input.</p>
<p>3.2.4 Review each HTML form to identify any <code>disabled elements</code>, such as grayed-out submit buttons. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">disabled</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùtrue‚Äù</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùproduct‚Äù</span>&gt;
</span></span></code></pre></div><p>If you find any, submit these to the server, along with the form‚Äôs other parameters. See whether the parameter has any effect on the server‚Äôs processing that you can leverage in an attack. Alternatively, use an automated proxy rule to automatically enable disabled fields, such as
Burp Proxy‚Äôs ‚ÄúHTML Modification‚Äù rules.</p>
<h2 id="33-test-browser-extension-components">3.3 Test Browser Extension Components</h2>
<h3 id="331-understand-the-client-applications-operation">3.3.1 Understand the Client Application‚Äôs Operation</h3>
<p>3.3.1.1 Set up a local intercepting proxy for the client technology under review,
and monitor all traffic passing between the client and server. If data is serialized, use a deserialization tool such as Burp‚Äôs built-in AMF support or the <code>DSer</code> Burp plug-in for Java.</p>
<p>3.3.1.2 Step through the functionality presented in the client. Determine any potentially sensitive or powerful functions, using standard tools within the intercepting proxy to replay key requests or modify server responses.</p>
<h3 id="332-decompile-the-client">3.3.2 Decompile the Client</h3>
<p>3.3.2.1 Identify any applets employed by the application. Look for any of the following file types being requested via your intercepting proxy:</p>
<ul>
<li><code>.class</code>, <code>.jar</code> : Java</li>
<li><code>.swf</code> : Flash</li>
<li><code>.xap</code> : Silverlight</li>
</ul>
<p>You can also look for <code>applet tags</code> within the HTML source code of application pages. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span>&lt;<span style="color:#f92672">applet</span> <span style="color:#a6e22e">code</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äùinput.class‚Äù</span> <span style="color:#a6e22e">id</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚ÄùTheApplet‚Äù</span> <span style="color:#a6e22e">codebase</span><span style="color:#f92672">=</span><span style="color:#e6db74">‚Äù/scripts/‚Äù</span>&gt;&lt;/
</span></span><span style="display:flex;"><span><span style="color:#f92672">applet</span>&gt;
</span></span></code></pre></div><p>3.3.2.2 Review all calls made to the <code>applet‚Äôs methods</code> from within the invoking
HTML, and determine whether data returned from the applet is being submitted to the server. If this data is opaque (that is, obfuscated or encrypted), to modify it you will probably need to <code>decompile</code> the applet to obtain its source code.</p>
<p>3.3.2.3 Download the applet bytecode by entering the URL into your browser, and save the file locally. The name of the bytecode fi le is specified in the code attribute of the applet tag. The file will be located in the directory specified in the codebase attribute if this is present. Otherwise, it
will be located in the same directory as the page in which the applet tag appears.</p>
<p>3.3.2.4 Use a suitable tool to decompile the bytecode into source code. For example:
<code>C:\&gt;jad.exe input.class Parsing input.class... Generating input.jad</code>
Here are some suitable tools for decompiling different browser extension components:</p>
<ul>
<li>Java ‚Äî Jad</li>
<li>Flash ‚Äî SWFScan, Flasm/Flare</li>
<li>Silverlight ‚Äî .NET Reflector</li>
</ul>
<p>3.3.2.6 Determine whether the applet contains any public methods that can be used to perform the relevant obfuscation on arbitrary input.</p>
<p>3.3.2.7 If it doesn‚Äôt, modify the applet‚Äôs source to neutralize any validation it performs or to allow you to obfuscate arbitrary input. You can then recompile the source into its original fi le format using the compilation tools provided by the vendor.</p>
<h3 id="333-attach-a-debugger">3.3.3 Attach a Debugger</h3>
<p>3.3.3.1 For large client-side applications, it is often prohibitively difficult to
decompile the whole application. For these applications it is generally
quicker to attach a runtime debugger to the process. <code>JavaSnoop</code> does this
very well for Java. <code>Silverlight Spy</code> is a freely available tool that allows
runtime monitoring of Silverlight clients</p>
<p>3.3.3.2 Locate the key functions and values the application employs to drive
security-related business logic, and place breakpoints when the targeted
function is called. Modify the arguments or return value as needed to affect the security bypass.</p>
<h3 id="334-test-activex-controls">3.3.4 Test ActiveX controls</h3>
<p>3.3.4.1 Identify any ActiveX controls employed by the application. Look for
any .cab fi le types being requested via your intercepting proxy, or look
for object tags within the HTML source code of application pages. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>OBJECT
</span></span><span style="display:flex;"><span> classid<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">‚Äù</span>CLSID:<span style="color:#ae81ff">4</span>F878398<span style="color:#f92672">-</span>E58A<span style="color:#f92672">-</span><span style="color:#ae81ff">11</span>D3<span style="color:#f92672">-</span>BEE9<span style="color:#f92672">-</span><span style="color:#ae81ff">00</span>C04FA0D6BA<span style="color:#960050;background-color:#1e0010">‚Äù</span>
</span></span><span style="display:flex;"><span> codebase<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">‚Äù</span>https:<span style="color:#f92672">//</span>wahh app<span style="color:#f92672">.</span>com<span style="color:#f92672">/</span>scripts<span style="color:#f92672">/</span>input<span style="color:#f92672">.</span>cab<span style="color:#960050;background-color:#1e0010">‚Äù</span>
</span></span><span style="display:flex;"><span> id<span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">‚Äù</span>TheAxControl<span style="color:#960050;background-color:#1e0010">‚Äù</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/</span>OBJECT<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>3.3.4.2 It is usually possible to subvert any input validation performed within
an ActiveX control by attaching a debugger to the process and directly
modifying data being processed or altering the program‚Äôs execution path.</p>
<p>3.3.4.3 It is often possible to guess the purpose of different methods that an
ActiveX control exports based on their names and the parameters passed to them. Use the <code>COMRaider</code> tool to enumerate the methods exported by the control. Test whether any of these can be manipulated to affect the control‚Äôs behavior and defeat any validation tests it implements.</p>
<p>3.3.4.4 If the control‚Äôs purpose is to gather or verify certain information about
the client computer, use the <code>Filemon</code> and <code>Regmon</code> tools to monitor the
information the control gathers.</p>
<p>3.3.4.5 Test any ActiveX controls for vulnerabilities that could be exploited to
attack other users of the application. You can modify the HTML used
to invoke a control to pass arbitrary data to its methods and monitor
the results. Look for methods with dangerous-sounding names, such
as <code>LaunchExe</code>. You can also use <code>COMRaider</code> to perform some basic fuzz
testing of ActiveX controls to identify flaws such as buffer overflows.</p>
<hr>
<h1 id="4-test-the-authentication-mechanism"><code>4 Test the Authentication Mechanism</code></h1>
<h2 id="41-understand-the-mechanism">4.1 Understand the Mechanism</h2>
<p>4.1.1 Establish the <code>authentication technologies</code> in use (for example, forms,
certificates, or multifactor).</p>
<p>4.1.2 Locate all the authentication-related functionality (including login,
registration, account recovery, and so on).</p>
<p>4.1.3 If the application does not implement an automated self-registration
mechanism, determine whether any other means exists of obtaining several user accounts.</p>
<h2 id="42-test-password-quality">4.2 Test Password Quality</h2>
<p>4.2.1 Review the application for any description of the minimum quality rules
enforced on user passwords.</p>
<p>4.2.2 Attempt to set various kinds of weak passwords, using any self-registration
or password change functions to establish the rules actually enforced.
Try short passwords, alphabetic characters only, single-case characters
only, dictionary words, and the current username.</p>
<p>4.2.3 Test for incomplete validation of credentials. Set a strong and complex
password (for example, 12 characters with mixed-case letters, numerals, and typographic characters). Attempt to log in using different variations on this password, by removing the last character, by changing a character‚Äôs case, and by removing any special characters.</p>
<p>4.2.4 Having established the minimum password quality rules, and the extent
of password validation, identify the range of values that a <code>passwordguessing</code> attack would need to employ to have a good probability of success.</p>
<h2 id="43-test-for-username-enumeration">4.3 Test for Username Enumeration</h2>
<p>4.3.1 Identify every location within the various authentication functions
where a <code>username</code> is submitted, including via an on-screen input field,
a hidden form field, or a cookie. Common locations include the primary
login, self-registration, password change, logout, and account recovery.</p>
<p>4.3.2 For each location, submit two requests, containing a valid and an invalid
username. Review every detail of the server‚Äôs responses to each pair of
requests, including the HTTP status code, any redirects, information
displayed on-screen, any differences hidden in the HTML page source,
and the time taken for the server to respond.</p>
<p>4.3.3 If you observe any differences between the responses where a valid and
invalid username is submitted, repeat the test with a different pair of
values and confirm that a systematic difference exists that can provide a basis for automated username enumeration.</p>
<p>4.3.4 Check for any other sources of information leakage within the application that may enable you to compile a list of valid usernames. Examples are <code>logging functionality</code>, actual listings of <code>registered users</code>, and direct mention of names or e-mail addresses in source code comments.</p>
<p>4.3.5 Locate any subsidiary authentication that accepts a username, and determine whether it can be used for username enumeration. Pay specific attention to a <code>registration page</code> that allows specification of a username.</p>
<h2 id="44-test-resilience-to-password-guessing">4.4 Test Resilience to Password Guessing</h2>
<p>4.4.1 Identify every location within the application where <code>user credentials</code> are submitted. The two main instances typically are the main login function and the password change function.</p>
<p>4.4.2 At each location, using an account that you control, manually send several requests containing the valid username but other invalid credentials. Monitor the application‚Äôs responses to identify any differences. After about 10 failed logins, if the application has not returned a message about account lockout, submit a request containing valid credentials. If this request succeeds, an account lockout policy probably is not in force.</p>
<p>4.4.3 If you do not control any accounts, attempt to enumerate or guess a valid username, and make several invalid requests using this guess, monitoring for any error messages about account lockout.</p>
<h2 id="45-test-any-account-recovery-function">4.5 Test Any Account Recovery Function</h2>
<p>4.5.1 Identify whether the application contains any facility for users to regain
control of their account if they have forgotten their credentials.</p>
<p>4.5.2 Establish how the account recovery function works by doing a <code>complete walk-through</code> of the recovery process using an account you control.</p>
<p>4.5.3 If the function uses a challenge such as a secret question, determine
whether users can set or select their own challenge during registration.
If so, use a list of enumerated or common usernames to <code>harvest a list of challenges</code>, and review this for any that appear to be easily guessable.</p>
<p>4.5.4 If the function uses a <code>password hint</code>, perform the same exercise to harvest a list of password hints, and identify any that appear to be easily guessable.</p>
<p>4.5.5 Perform the same tests on any account-recovery challenges that you performed at the main login function to assess vulnerability to automated guessing attacks.</p>
<p>4.5.6 If the function involves sending an e-mail to the user to complete the
recovery process, look for any weaknesses that may enable you to take
control of other users‚Äô accounts. Determine whether it is possible to
control the address to which the e-mail is sent. If the message contains
a unique recovery URL, obtain a number of messages using an e-mail
address you control, and attempt to identify any patterns that may enable
you to predict the URLs issued to other users. Apply the methodology
described in step 5.3 to identify any predictable sequences.</p>
<h2 id="46-test-any-remember-me-function">4.6 Test Any Remember Me Function</h2>
<p>4.6.1 If the main login function or its supporting logic contains a <code>Remember Me function</code>, activate this and review its effects. If this function allows the
user to log in on subsequent occasions without entering any credentials,
you should review it closely for any vulnerabilities.</p>
<p>4.6.2 Closely inspect all persistent <code>cookies</code> that are set when the Remember Me
function is activated. Look for any data that identifies the user explicitly
or appears to contain some predictable identifier of the user.</p>
<p>4.6.3 Even where the data stored appears to be heavily encoded or obfuscated,
review this closely, and compare the results of remembering several very
<code>similar usernames and/or passwords</code> to identify any opportunities to
reverse-engineer the original data. Apply the methodology described in step 5.2 to identify any meaningful data.</p>
<p>4.6.4 Depending on your results, modify the contents of your cookie in suitable ways in an attempt to masquerade as other users of the application.</p>
<h2 id="47-test-any-impersonation-function">4.7 Test Any Impersonation Function</h2>
<p>4.7.1 If the application contains any explicit functionality that allows one
user to impersonate another, review this closely for any vulnerabilities
that may enable you to impersonate arbitrary users without proper authorization.</p>
<p>4.7.2 Look for any user-supplied data that is used to determine the target
of the impersonation. Attempt to manipulate this to impersonate other users, particularly administrative users, which may enable you escalate privileges.</p>
<p>4.7.3 If you perform any automated password-guessing attacks against other
user accounts, look for any accounts that appear to have more than one
valid password, or multiple accounts that appear to have the same password. This may indicate the presence of a backdoor password, which administrators can use to access the application as any user.</p>
<h2 id="48-test-username-uniqueness">4.8 Test Username Uniqueness</h2>
<p>4.8.1 If the application has a self-registration function that lets you specify
a desired username, attempt to register the same username twice with different passwords.</p>
<p>4.8.2 If the application blocks the second registration attempt, you can exploit
this behavior to enumerate registered usernames.</p>
<p>4.8.3 If the application registers both accounts, probe further to determine its
behavior when a collision of username and password occurs. Attempt
to change the password of one of the accounts to match that of the
other. Also, attempt to register two accounts with identical usernames and passwords.</p>
<p>4.8.4 If the application alerts you or generates an error when a collision of
username and password occurs, you can probably exploit this to perform an automated guessing attack to discover another user‚Äôs password. Target an enumerated or guessed username, and attempt to create accounts that have this username and different passwords. When the application rejects a specific password, you have probably found the existing password for the targeted account.</p>
<p>4.8.5 If the application appears to tolerate a collision of username and password without an error, log in using the colliding credentials. Determine what happens and whether the application‚Äôs behavior can be leveraged to gain unauthorized access to other users‚Äô accounts.</p>
<h2 id="49-test-predictability-of-autogenerated-credentials">4.9 Test Predictability of Autogenerated Credentials</h2>
<p>4.9.1 If the application automatically generates usernames or passwords, try
to obtain several values in quick succession and identify any detectable sequences or patterns.</p>
<p>4.9.2 If usernames are generated in a predictable way, extrapolate backwards
to obtain a list of possible valid usernames. You can use this as the basis for automated password-guessing and other attacks.</p>
<p>4.9.3 If passwords are generated in a predictable way, extrapolate the pattern
to obtain a list of possible passwords issued to other application users.</p>
<h2 id="410-check-for-unsafe-transmission-of-credentials">4.10 Check for Unsafe Transmission of Credentials</h2>
<p>4.10.1 Walk through all authentication-related functions that involve transmission of credentials, including the main login, account registration, password change, and any page that allows viewing or updating of user profile information. Monitor all traffic passing in both directions
between the client and server using your intercepting proxy.</p>
<p>4.10.2 Identify every case in which the credentials are transmitted in either
direction. You can set interception rules in your proxy to flag messages containing specific strings.</p>
<p>4.10.3 If credentials are ever transmitted in the URL query string, these are
potentially vulnerable to disclosure in the browser history, on-screen,
in server logs, and in the <code>Referer</code> header when third-party links are followed.</p>
<p>4.10.4 If credentials are ever stored in a cookie, these are potentially vulnerable
to disclosure via <code>XSS attacks</code> or local privacy attacks.</p>
<p>4.10.5 If credentials are ever transmitted from the server to the client, these
may be compromised via any vulnerabilities in <code>session management</code> or <code>access controls</code>, or in an <code>XSS</code> attack.</p>
<p>4.10.6 If credentials are ever transmitted over an unencrypted connection, these
are vulnerable to interception by an <code>eavesdropper</code>.</p>
<p>4.10.7 If credentials are submitted using HTTPS but the login form itself is
loaded using HTTP, the application is vulnerable to a <code>man-in-the-middle</code>
attack that may be used to capture credentials.</p>
<h2 id="411-check-for-unsafe-distribution-of-credentials">4.11 Check for Unsafe Distribution of Credentials</h2>
<p>4.11.1 If accounts are created via some out-of-band channel, or the application has a self-registration function that does not itself determine all of a user‚Äôs initial credentials, establish the means by which credentials are distributed to new users. Common methods include sending a message to an e-mail or postal address.</p>
<p>4.11.2 If the application generates account activation URLs that are distributed out-of-band, try to register several new accounts in close succession, and identify any sequence in the URLs you receive. If a pattern can be determined, try to predict the URLs sent to recent and forthcoming users, and attempt to use these URLs to take ownership of their accounts.</p>
<p>4.11.3 Try to reuse a single activation URL multiple times, and see if the application allows this. If it doesn‚Äôt, try locking out the target account before reusing the URL, and see if the URL still works. Determine whether this enables you to set a new password on an active account.</p>
<h2 id="412-test-for-insecure-storage">4.12 Test for Insecure Storage</h2>
<p>4.12.1 If you gain access to hashed passwords, check for accounts that share
the same hashed password value. Try to log in with common passwords for the most common hashed value.</p>
<p>4.12.2 Use an offline rainbow table for the hashing algorithm in question to
recover the cleartext value.</p>
<h2 id="413-test-for-logic-flaws">4.13 Test for Logic Flaws</h2>
<h3 id="4131-test-for-fail-open-conditions">4.13.1 Test for Fail-Open Conditions</h3>
<p>4.13.1.1 For each function in which the application checks a user‚Äôs credentials,
including the login and password change functions, walk through the
process in the normal way, using an account you control. Note every
request parameter submitted to the application.</p>
<p>4.13.1.2 Repeat the process numerous times, modifying each parameter in turn
in various unexpected ways designed to interfere with the application‚Äôs
logic. For each parameter, include the following changes:</p>
<ul>
<li>Submit an empty string as the value.</li>
<li>Remove the name/value pair.</li>
<li>Submit very long and very short values</li>
<li>Submit strings instead of numbers, and vice versa.</li>
<li>Submit the same named parameter multiple times, with the same and different values.</li>
</ul>
<p>4.13.1.3 Review closely the application‚Äôs responses to the preceding requests. If
any unexpected divergences from the base case occur, feed this observation back into your framing of further test cases. If one modification causes a change in behavior, try to combine this with other changes to push the application‚Äôs logic to its limits.</p>
<h3 id="4132-test-any-multistage-mechanisms">4.13.2 Test Any Multistage Mechanisms</h3>
<p>4.13.2.1 If any authentication-related function involves submitting credentials
in a series of different requests, identify the apparent purpose of each
distinct stage, and note the parameters submitted at each stage.</p>
<p>4.13.2.2 Repeat the process numerous times, modifying the sequence of requests
in ways designed to interfere with the application‚Äôs logic, including the following tests:</p>
<ul>
<li>Proceed through all stages, but in a different sequence than the one intended.</li>
<li>Proceed directly to each stage in turn, and continue the normal sequence from there.</li>
<li>Proceed through the normal sequence several times, skipping each
stage in turn, and continuing the normal sequence from the next stage.</li>
<li>On the basis of your observations and the apparent purpose of each
stage of the mechanism, try to think of further ways to modify the
sequence and to access the different stages that the developers may not have anticipated.</li>
</ul>
<p>4.13.2.3 Determine whether any single piece of information (such as the username) is submitted at more than one stage, either because it is capture more than once from the user or because it is transmitted via the client in a hidden form field, cookie, or preset query string parameter. If so, try
submitting different values at different stages (both valid and invalid) and observing the effect. Try to determine whether the submitted item is sometimes superfluous, or is validated at one stage and then trusted subsequently, or is validated at different stages against different checks.
Try to exploit the application‚Äôs behavior to gain unauthorized access or reduce the effectiveness of the controls imposed by the mechanism.</p>
<p>4.13.2.4 Look for any data that is transmitted via the client that has not been
captured from the user at any point. If hidden parameters are used to track the state of the process across successive stages, it may be possible to interfere with the application‚Äôs logic by modifying these parameters in crafted ways.</p>
<p>4.13.2.5 If any part of the process involves the application‚Äôs presenting a randomly varying challenge, test for two common defects:</p>
<ul>
<li>If a parameter specifying the challenge is submitted along with the
user‚Äôs response, determine whether you can effectively choose your
own challenge by modifying this value.</li>
<li>Try proceeding as far as the varying challenge several times with
the same username, and determine whether a different challenge
is presented. If it is, you can effectively choose your own challenge by proceeding to this stage repeatedly until your desired challenge is presented.</li>
</ul>
<h2 id="414-exploit-any-vulnerabilities-to-gain-unauthorized-access">4.14 Exploit Any Vulnerabilities to Gain Unauthorized Access</h2>
<p>4.14.1 Review any vulnerabilities you have identified within the various authentication functions, and identify any that you can leverage to achieve your objectives in attacking the application. This typically involves attempting to authenticate as a different user ‚Äî if possible, a user with
administrative privileges.</p>
<p>4.14.2 Before mounting any kind of automated attack, note any account lockout defenses you have identified. For example, when performing username enumeration against a login function, submit a common password with each request rather than a completely arbitrary value
so as not to waste a failed login attempt on every username discovered. Similarly, perform any password-guessing attacks on a breadth-first, not depth-first, basis. Start your word list with the most common weak passwords, and proceed through this list, trying each item against every enumerated username.</p>
<p>4.14.3 Take account of the password quality rules and the completeness of
password validation when constructing word lists to use in any <code>passwordguessing</code> attack to avoid impossible or superfluous test cases.</p>
<p>4.14.4 Use the techniques described in [Chapter 14: Automating Customized Attacks] to automate as much work as possible and maximize the speed and effectiveness of your attacks.</p>
<hr>
<h1 id="5-test-the-session-management-mechanism"><code>5 Test the Session Management Mechanism</code></h1>
<h2 id="51-understand-the-mechanism">5.1 Understand the Mechanism</h2>
<p>5.1.1 Analyze the mechanism used to manage sessions and state. Establish
whether the application uses session tokens or some other method of
handling the series of requests received from each user. Note that some
authentication technologies (such as HTTP authentication) may not
require a full session mechanism to reidentify users post-authentication.
Also, some applications use a <code>sessionless</code> state mechanism in which all
state information is transmitted via the client, usually in an encrypted or obfuscated form.</p>
<p>5.1.2 If the application uses session tokens, confirm precisely which pieces
of data are actually used to reidentify users. Items that may be used to transmit tokens include HTTP cookies, query string parameters, and hidden form fields. Several different pieces of data may be used collectively to reidentify the user, and different items may be used by different
back-end components. Often, items that look like session tokens may not actually be employed as such by the application, such as the default cookie generated by the web server.</p>
<p>5.1.3 To verify which items are actually being employed as session tokens,
find a page or function that is certainly session-dependent (such as a
user-specific <code>My Details page</code>). Then make several requests for it, systematically removing each item you suspect is being used as a session token. If removing an item stops the session-dependent page from being returned, this may confirm that the item is a session token. <code>Burp Repeater</code>
is a useful tool for performing these tests.</p>
<p>5.1.4 Having established which items of data are actually being used to reidentify users, for each token confirm whether it is being validated in its entirety, or whether some subcomponents of the token are ignored. Change the token‚Äôs value <code>1 byte at a time</code>, and check whether the modified value is still accepted. If you find that certain portions of the token are not actually used to maintain session state, you can exclude these from further analysis.</p>
<h2 id="52-test-tokens-for-meaning">5.2 Test Tokens for Meaning</h2>
<p>5.2.1 Log in as several different users at different times, and record the tokens
received from the server. If self-registration is available and you can choose
your username, log in with a series of similar usernames that have small
variations, such as <code>A, AA, AAA, AAAA, AAAB, AAAC, AABA</code>, and so
on. If other user-specific data is submitted at the login or is stored in user
profiles (such as an e-mail address), perform a similar exercise to modify
that data systematically and capture the resulting tokens.</p>
<p>5.2.2 Analyze the tokens you receive for any correlations that appear to be
related to the username and other user-controllable data.</p>
<p>5.2.3 Analyze the tokens for any detectable encoding or obfuscation. Look for a correlation between the length of the username and the length of the token, which strongly indicates that some kind of obfuscation or encoding is in use. Where the username contains a sequence of the same
character, look for a corresponding character sequence in the token, which may indicate the use of <code>XOR obfuscation</code>. Look for sequences in the token that contain only hexadecimal characters, which may indicate hexadecimal encoding of an <code>ASCII string</code> or other information. Look for
sequences ending in an equals sign and/or containing only the other valid Base64 characters: a to z, A to Z, 0 to 9, +, and /.</p>
<p>5.2.4 If you can identify any meaningful data within your sample of session tokens, consider whether this is sufficient to mount an attack that attempts to guess the tokens recently issued to other application users. Find a page of the application that is session-dependent, and use the techniques described in [Chapter 14: Automating Customized Attacks] to automate the task of generating and testing possible tokens.</p>
<h2 id="53-test-tokens-for-predictability">5.3 Test Tokens for Predictability</h2>
<p>5.3.1 Generate and capture a large number of session tokens in quick succession, using a request that causes the server to return a new token (for example, a successful login request)</p>
<p>5.3.2 Attempt to identify any patterns within your sample of tokens. In all
cases you should use <code>Burp Sequencer</code>, as described in [Chapter 7: Attacking Session Management], to perform detailed statistical tests of the randomness properties of the
application‚Äôs tokens. Depending on the results, it may also be useful to perform the following manual analysis:</p>
<ul>
<li>Apply your understanding of which tokens and subsequences the application actually uses to reidentify users. Ignore any data that is not used in this way, even if it varies between samples.</li>
<li>If it is unclear what type of data is contained in the token, or in any individual component of it, try applying various <code>decodings</code> (for example, Base64) to see if any more meaningful data emerges. It may be necessary to apply several <code>decodings</code> in sequence.</li>
<li>Try to identify any patterns in the sequences of values contained in each decoded token or component. Calculate the differences between successive values. Even if these appear to be chaotic, there may be a fixed set of observed differences, which narrows down the scope of
any brute-force attack considerably.</li>
<li>Obtain a similar sample of tokens after waiting for a few minutes,
and repeat the same analysis. Try to detect whether any of the tokens‚Äô content is <code>time-dependent.</code></li>
</ul>
<p>5.3.3 If you identify any patterns, capture a second sample of tokens using a <code>different IP address</code> and a <code>different username</code>. This will help you identify whether the same pattern is detected and whether tokens received in the first exercise could be extrapolated to guess tokens
received in the second.</p>
<p>5.3.4 If you can identify any exploitable sequences or time dependencies, consider whether this is sufficient to mount an attack that attempts to guess the tokens recently issued to other application users. Use the techniques described in [Chapter 14: Automating Customized Attacks] to automate the task of generating and testing possible tokens. Except in the simplest kind of sequences, it is likely that your attack will need to involve a customized script of some kind.</p>
<p>5.3.5 If the session ID appears to be custom-written, use the <code>bit flipper</code> payload source in Burp Intruder to sequentially modify each bit in the session token in turn. Grep for a string in the response that indicates whether modifying the token has not resulted in an invalid session, and
whether the session belongs to a different user.</p>
<h2 id="54-check-for-insecure-transmission-of-tokens">5.4 Check for Insecure Transmission of Tokens</h2>
<p>5.4.1 Walk through the application as normal, starting with unauthenticated content at the start URL, proceeding through the login process, and then going through all the application‚Äôs functionality. Make a note of every occasion on which a new session token is issued, and which
portions of your communications use HTTP and which use HTTPS. You can use the logging function of your intercepting proxy to record this information.</p>
<p>5.4.2 If HTTP cookies are being used as the transmission mechanism for session tokens, verify whether the secure flag is set, preventing them from ever being transmitted over HTTP connections.</p>
<p>5.4.3 Determine whether, in the normal use of the application, session tokens
are ever transmitted over an <code>HTTP connection</code>. If so, they are vulnerable to interception.</p>
<p>5.4.4 In cases where the application uses HTTP for unauthenticated areas and switches to HTTPS for the login and/or authenticated areas of the application, verify whether a new token is issued for the HTTPS portion of the communications, or whether a token issued during the
HTTP stage remains active when the application switches to HTTPS. If a token issued during the HTTP stage remains active, the token is vulnerable to interception.</p>
<p>5.4.5 If the HTTPS area of the application contains any links to HTTP URLs, follow these and verify whether the session token is submitted. If it is, determine whether it continues to be valid or is immediately terminated by the server.</p>
<h2 id="55-check-for-disclosure-of-tokens-in-logs">5.5 Check for Disclosure of Tokens in Logs</h2>
<p>5.5.1 If your application mapping exercises identified any logging, monitoring, or diagnostic functionality, review these functions closely to determine whether any session tokens are disclosed within them. Confirm who is normally authorized to access these functions. If they are intended for
administrators only, determine whether any other vulnerabilities exist that could enable a lower-privileged user to access them.</p>
<p>5.5.2 Identify any instances where session tokens are transmitted within the URL. It may be that tokens are generally transmitted in a more secure manner, but that developers have used the URL in specific cases to work around a particular problem. If so, these may be transmitted in
the Referrer header when users follow any off-site links. Check for any functionality that enables you to inject arbitrary off-site links into pages viewed by other users.</p>
<p>5.5.3 If you find any way to gather valid session tokens issued to other users,
look for a way to test each token to determine whether it belongs to an
administrative user (for example, by attempting to access a <code>privileged function</code> using the token).</p>
<h2 id="56-check-mapping-of-tokens-to-sessions">5.6 Check Mapping of Tokens to Sessions</h2>
<p>5.6.1 Log in to the application twice using the same user account, either from
different browser processes or from different computers. Determine whether both sessions remain active concurrently. If they do, the application supports concurrent sessions, enabling an attacker who has compromised another user‚Äôs credentials to use these without risk of detection.
5.6.2 Log in and log out several times using the same user account, either from
different browser processes or from different computers. Determine whether a new session token is issued each time, or whether the same token is issued every time the same account logs in. If the latter occurs, the application is not really employing proper session tokens, but is
using unique persistent strings to reidentify each user. In this situation, there is no way to protect against concurrent logins or properly enforce session timeout.
5.6.3 If tokens appear to contain any structure and meaning, attempt to separate out components that may identify the user from those that appear to be inscrutable. Try to modify any user-related components of the token so that they refer to other known users of the application. Verify whether
the application accepts the resulting token and whether it enables you to masquerade as that user. See [Chapter 7: Attacking Session Management] for examples of this kind of subtle vulnerability.</p>
<h2 id="57-test-session-termination">5.7 Test Session Termination</h2>
<p>5.7.1 When testing for session timeout and logout flaws, focus solely on the
server‚Äôs handling of sessions and tokens, rather than any events that occur
on the client. In terms of session termination, nothing much depends on
what happens to the token within the client browser.</p>
<p>5.7.2 Check whether session expiration is implemented on the server:</p>
<ul>
<li>Log in to the application to obtain a valid session token.</li>
<li>Wait for a period without using this token, and then submit a request for a protected page (such as My Details) using the token.</li>
<li>If the page is displayed normally, the token is still active.</li>
<li>Use trial and error to determine how long any session expiration timeout is, or whether a token can still be used days after the previous request that used it. <code>Burp Intruder</code> can be configured to increment the time interval between successive requests to automate this task.</li>
</ul>
<p>5.7.3 Check whether a logout function exists. If it does, test whether it effectively invalidates the user‚Äôs session on the server. After logging out, attempt to reuse the old token, and determine whether it is still valid by requesting a protected page using the token. If the session is still active,
users remain vulnerable to some session hijacking attacks even after they have ‚Äúlogged out.‚Äù You can use <code>Burp Repeater</code> to keep sending a specific request from the proxy history to see whether the application responds differently after you log out.</p>
<h2 id="58-check-for-session-fixation">5.8 Check for Session Fixation</h2>
<p>5.8.1 If the application issues session tokens to unauthenticated users, obtain a token and perform a login. If the application does not issue a fresh token following a successful login, it is vulnerable to <code>session fixation</code>.
5.8.2 Even if the application does not issue session tokens to unauthenticated users, obtain a token by logging in, and then return to the login page. If the application is willing to return this page even though you are already authenticated, submit another login as a different user using the <strong>same
token</strong>. If the application does not issue a fresh token after the second login, it is vulnerable to session fixation.
5.8.3 Identify the format of session tokens that the application uses. Modify your token to an invented value that is validly formed, and attempt to log in. If the application allows you to create an authenticated session using an invented token, it is vulnerable to session fixation.
5.8.4 If the application does not support login, but processes sensitive user information (such as personal and payment details) and allows this to be displayed after submission (such as on a Verify My Order page), carry out the preceding three tests in relation to the pages displaying
sensitive data. If a token set during anonymous usage of the application can later be used to retrieve sensitive user information, the application is vulnerable to session fixation.</p>
<h2 id="59-check-for-csrf">5.9 Check for CSRF</h2>
<p>5.9.1 If the application relies solely on HTTP cookies as its method of transmitting session tokens, it may be vulnerable to cross-site request forgery attacks.
5.9.2 Review the application‚Äôs key functionality, and identify the specific requests that are used to perform sensitive actions. If an attacker can fully determine in advance parameters for any of these requests (that is, they do not contain any session tokens, unpredictable data, or other  secrets), the application is almost certainly vulnerable.
5.9.3 Generate the CSRF POC from this link ‚áí <a href="https://github.com/merttasci/csrf-poc-generator">https://github.com/merttasci/csrf-poc-generator</a>
5.9.4 If the application uses additional tokens within requests in an attempt to 
prevent CSRF attacks, test the robustness of these in the same manner as  for session tokens. Also test whether the application is vulnerable to UI  redress attacks, in order to defeat the anti-CSRF defenses (see [Chapter 13: Attacking Users: Other Techniques] for more details).</p>
<h2 id="510-check-cookie-scope">5.10 Check Cookie Scope</h2>
<p>5.10.1 If the application uses HTTP cookies to transmit session tokens (or any other sensitive data), review the relevant <code>Set-Cookie</code> headers, and check for any domain or path attributes used to control the scope of the cookies.
5.10.2 If the application explicitly liberalizes its cookies‚Äô scope to a parent domain or parent directory, it may be leaving itself vulnerable to attacks via other web applications that are hosted within the parent domain or directory.
5.10.3 If the application sets its cookies‚Äô domain scope to its own domain name (or does not specify a domain attribute), it may still be exposed to attacks via any applications hosted on subdomains. This is a consequence of how cookie scoping works. It cannot be avoided other than by not hosting any other applications on a subdomain of a <code>securitysensitive application</code>.</p>
<p>5.10.4 Determine any reliance on segregation by path, such as <code>/site/main</code> and
<code>/site/demo</code>, which can be subverted in the event of a cross-site scripting attack.
5.10.5 Identify all the possible domain names and paths that will receive the cookies that the application issues. Establish whether any other web applications are accessible via these domain names or paths that you may be able to leverage to capture the cookies issued to users of the
target application.</p>
<hr>
<h1 id="6-test-access-controls"><code>6 Test Access Controls</code></h1>
<h2 id="61-understand-the-access-control-requirements">6.1 Understand the Access Control Requirements</h2>
<p>6.1.1 Based on the core functionality implemented within the application, understand the broad requirements for access control in terms of vertical segregation (different levels of users have access to different types of functionality) and horizontal segregation (users at the same privilege
level have access to different subsets of data). Often, both types of segregation are present. For example, ordinary users may be able to access their own data, while administrators can access everyone‚Äôs data.
6.1.2 Review your application mapping results to identify the areas of functionality and types of data resources that represent the most fruitful targets for <code>privilege escalation</code> attacks.
6.1.3 To perform the most effective testing for access control vulnerabilities, you should ideally obtain a number of different accounts with different vertical and horizontal privileges. If self-registration is possible, you can probably obtain the latter directly from the application. To obtain the former, you will probably need the cooperation of the application owner (or need to exploit some vulnerability to gain access to a high-privileged account). The availability of different kinds of accounts will affect the types of testing you can perform, as described next.</p>
<h2 id="62-test-with-multiple-accounts">6.2 Test with Multiple Accounts</h2>
<p>6.2.1 If the application enforces vertical privilege segregation, first use a powerful account to locate all the functionality it can access. Then use a less-privileged account and attempt to access each item of this functionality.
6.2.1.1 Using <code>Burp</code>, browse all the application‚Äôs content within one user context.
6.2.1.2 Review the contents of Burp‚Äôs <code>site map</code> to ensure you have identified all the functionality you want to test. Then, log out of the application and log back in using a different user context.
Use the context menu to select the <code>compare site maps</code> feature to determine which high-privileged requests may be accessible to the lower-privileged user. See [Chapter 8: Attacking Access Controls] for more details on this technique.
6.2.2 If the application enforces horizontal privilege segregation, perform the equivalent test using two different accounts at the same privilege level, attempting to use one account to access data belonging to the other account. This typically involves replacing an identifier (such as
a document ID) within a request to specify a resource belonging to the other user.
6.2.3 Perform manual checking of key access control logic.
6.2.3.1 For each user privilege, review resources available to a user.
Attempt to access those resources from an unauthorized user
account by replaying the request using the unauthorized user‚Äôs session token.
6.2.4 When you perform any kind of access control test, be sure to test every step of multistage functions individually to confirm whether access controls have been properly implemented at each stage, or whether the application assumes that users who access a later stage must have passed security checks implemented at the earlier stages. For example, if an administrative
page containing a form is properly protected, check whether the actual form submission is also subjected to proper access controls.</p>
<h2 id="63-test-with-limited-access">6.3 Test with Limited Access</h2>
<p>6.3.1 If you do not have prior access to accounts at different privilege levels, or to multiple accounts with access to different data, testing for broken access controls is not quite as straightforward. Many common vulnerabilities will be much harder to locate, because you do not know the names of the URLs, identifiers, and parameters that are needed to exploit the weaknesses.</p>
<p>6.3.2 In your application mapping exercises that use a low-privileged account, you may have identified the URLs for privileged functions such as administrative interfaces. If these are not adequately protected, you will probably already know about this.
6.3.3 Decompile all compiled clients that are present, and extract any references to server-side functionality.
6.3.4 Most data that is subject to horizontal access controls is accessed using an identifier, such as an account number or order reference. To test whether access controls are effective using only a single account, you must try to guess or discover the identifiers associated with other users‚Äô
data. If possible, generate a series of identifiers in quick succession (for example, by creating several new orders). Attempt to identify any patterns that may enable you to predict the identifiers issued to other users. If there is no way to generate new identifiers, you are probably restricted to analyzing those you already have and guessing on that basis.
6.3.5 If you find a way to predict the identifiers issued to other users, use the techniques described in [Chapter 14: Automating Customized Attacks] to mount an automated attack to harvest interesting data belonging to other users. Use the Extract Grep function in <code>Burp Intruder</code> to capture the relevant information from within the application‚Äôs responses.</p>
<h2 id="64-test-for-insecure-access-control-methods">6.4 Test for Insecure Access Control Methods</h2>
<p>6.4.1 Some applications implement access controls based on request parameters in an inherently unsafe way. Look for parameters such as <code>edit=false</code> or <code>access=read</code> in any key requests, and modify these in line with their apparent role to try to interfere with the application‚Äôs access control logic.
6.4.2 Some applications base access control decisions on the HTTP <code>Referer</code> header. For example, an application may properly control access to <code>/admin.jsp</code> and accept any request showing this as its <code>Referer</code>. To test for this behavior, attempt to perform some privileged actions to which you are authorized, and submit a missing or modified <code>Referer</code> header. If this change causes the application to block your request, it may be using the <code>Referer</code> header in an unsafe way. Try performing the same action as an unauthorized user, but supply the original <code>Referer</code> header and see whether the action succeeds.
6.4.3 If <code>HEAD</code> is an allowed method on the site, test for insecure <code>containermanaged</code> access control to URLs. Make a request using the HEAD method to determine whether the application permits it.</p>
<hr>
<h1 id="7-test-for-input-based-vulnerabilities"><code>7 Test for Input-Based Vulnerabilities</code></h1>
<h2 id="71-fuzz-all-request-parameters">7.1 Fuzz All Request Parameters</h2>
<p>7.1.1 Review the results of your application mapping exercises and identify every distinct client request that submits parameters that the server-side application processes. Relevant parameters include items within the <code>URL query string</code>, <code>parameters</code> in the request body, and HTTP cookies. Also include any other items of user input that have been observed to have an
effect on the application‚Äôs behavior, such as the <code>Referer</code> or <code>User-Agent</code> headers.</p>
<p>7.1.2 To fuzz the parameters, you can use your own scripts or a ready-made fuzzing tool. For example, to use <code>Burp Intruder</code>, load each request in turn into the tool. An easy way to do this is to intercept a request in Burp Proxy and select the Send to Intruder action, or right-click an item in the
Burp Proxy history and select this option. Using this option configures Burp Intruder with the contents of the request, along with the correct target host and port. It also automatically marks the values of all request parameters as payload positions, ready for fuzzing.</p>
<p>7.1.3 Using the payloads tab, configure a suitable set of attack payloads to probe for vulnerabilities within the application. You can enter payloads manually, load them from a file, or select one of the preset payload lists. Fuzzing every request parameter within the application typically entails
issuing a large number of requests and reviewing the results for anomalies. If your set of attack strings is too large, this can be counterproductive and generate a prohibitively large amount of output for you to review. Hence, a sensible approach is to target a range of common vulnerabilities that can often be easily detected in anomalous responses to specific crafted inputs and that often manifest themselves anywhere within the application rather than within specific types of functionality. Here is a suitable set of payloads that you can use to test for some common
categories of vulnerabilities:</p>
<p><strong>SQL Injection:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚Äò</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚Äò</span><span style="color:#75715e">--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">‚Äò</span>; waitfor delay <span style="color:#960050;background-color:#1e0010">‚Äò</span><span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">30</span>:<span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">‚Äô</span><span style="color:#75715e">--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">1</span>; waitfor delay <span style="color:#960050;background-color:#1e0010">‚Äò</span><span style="color:#ae81ff">0</span>:<span style="color:#ae81ff">30</span>:<span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">‚Äô</span><span style="color:#75715e">--
</span></span></span></code></pre></div><p><strong>XSS and Header Injection</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>xsstest
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">‚Äú</span><span style="color:#f92672">&gt;&lt;</span>script<span style="color:#f92672">&gt;</span>alert(<span style="color:#960050;background-color:#1e0010">‚Äò</span>xss<span style="color:#960050;background-color:#1e0010">‚Äô</span>)<span style="color:#f92672">&lt;/</span>script<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p><strong>OS Command Injection</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#f92672">||</span> ping <span style="color:#f92672">-</span>i <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> ; x <span style="color:#f92672">||</span> ping <span style="color:#f92672">-</span>n <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> ping <span style="color:#960050;background-color:#1e0010">‚Äì</span>i <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span> ping <span style="color:#960050;background-color:#1e0010">‚Äì</span>n <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&amp;</span> ping <span style="color:#960050;background-color:#1e0010">‚Äì</span>i <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&amp;</span> ping <span style="color:#960050;background-color:#1e0010">‚Äì</span>n <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>; ping <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> ;
</span></span><span style="display:flex;"><span><span style="color:#f92672">%</span><span style="color:#ae81ff">0</span>a ping <span style="color:#960050;background-color:#1e0010">‚Äì</span>i <span style="color:#ae81ff">30</span> <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">%</span><span style="color:#ae81ff">0</span>a
</span></span><span style="display:flex;"><span><span style="color:#f92672">`</span> ping <span style="color:#ae81ff">127</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">1</span> <span style="color:#f92672">`</span>
</span></span></code></pre></div><p><strong>Path Traversal</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>etc<span style="color:#f92672">/</span>passwd
</span></span><span style="display:flex;"><span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>..<span style="color:#f92672">/</span>boot.ini
</span></span><span style="display:flex;"><span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>etc<span style="color:#960050;background-color:#1e0010">\</span>passwd
</span></span><span style="display:flex;"><span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>..<span style="color:#960050;background-color:#1e0010">\</span>boot.ini
</span></span></code></pre></div><p><strong>Script Injection</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>;echo <span style="color:#ae81ff">111111</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#ae81ff">111111</span>
</span></span><span style="display:flex;"><span>response.<span style="color:#66d9ef">write</span> <span style="color:#ae81ff">111111</span>
</span></span><span style="display:flex;"><span>:response.<span style="color:#66d9ef">write</span> <span style="color:#ae81ff">111111</span>
</span></span></code></pre></div><p><strong>File Inclusion</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>http:<span style="color:#f92672">//&lt;</span>your server name<span style="color:#f92672">&gt;/</span>
</span></span><span style="display:flex;"><span>http:<span style="color:#f92672">//&lt;</span>nonexistent IP address<span style="color:#f92672">&gt;/</span>
</span></span></code></pre></div><p>7.1.4 All the preceding payloads are shown in their literal form. The characters
<code>?, ;, &amp;, +, =</code>, and space need to be URL-encoded because they have special meaning within HTTP requests. By default, Burp Intruder performs the necessary encoding of these characters, so ensure that this option has not been disabled. (To restore all options to their defaults following earlier customization, select Burp ‚Äö Restore Defaults.)</p>
<p>7.1.5 In the Grep function of Burp Intruder, configure a suitable set of strings
to flag some common error messages within responses. For example:</p>
<pre tabindex="0"><code>error
exception
illegal
invalid
fail
stack
access
directory
file
not found
varchar
ODBC
SQL 
SELECT
111111
=======================
Note that the string 111111 is included to test for successful script injection attacks.
The payloads in step 7.1.3 involve writing this value into  the server‚Äôs response.
</code></pre><p>7.1.6 Also select the Payload Grep option to flag responses that contain the payload itself, indicating a potential XSS or header injection vulnerability.</p>
<p>7.1.7 Set up a web server or <code>netcat</code> listener on the host you specified in the
first file inclusion payload. This helps you monitor for connection attempts received from the server resulting from a successful remote file inclusion attack.</p>
<p>7.1.8 Launch the attack. When it has completed, review the results for anomalous responses indicating the presence of vulnerabilities. Check for divergences in the HTTP status code, the response length, the response time, the appearance of your configured expressions, and the appearance of the payload itself. You can click each column heading in the results table to sort the results by the values in that column (and Shift-click to reverse-sort the results). This enables you to quickly identify any anomalies that stand out from the other results.</p>
<p>7.1.9 For each potential vulnerability indicated by the results of your fuzz testing, refer to the following sections of this methodology. They describe the detailed steps you should take in relation to each category of problem to verify the existence of a vulnerability and successfully exploit it.</p>
<p>7.1.10 After you have configured Burp Intruder to perform a fuzz test of a single request, you can quickly repeat the same test on other requests within the application. Simply select each target request within Burp Proxy and choose the Send to Intruder option. Then immediately launch the attack within Intruder using the existing attack configuration. In this way, you can launch a large number of tests simultaneously in separate windows and manually review the results as each test completes its work.</p>
<p>7.1.11 If your mapping exercises identified any out-of-band input channels whereby user-controllable input can be introduced into the application‚Äôs processing, you should perform a similar fuzzing exercise on these input channels. Submit various crafted data designed to trigger common vulnerabilities when processed within the web application. Depending on the nature of the input channel, you may need to create a custom script or other harness for this purpose.</p>
<p>7.1.12 In addition to your own fuzzing of application requests, if you have access to an automated web application vulnerability scanner, you should run it against the target application to provide a basis for comparison with your own findings.</p>
<h2 id="72-test-for-sql-injection">7.2 Test for SQL Injection</h2>
<p>7.2.1 If the SQL attack strings listed in step 7.1.3 result in any anomalous responses, probe the application‚Äôs handling of the relevant parameter manually to determine whether a SQL injection vulnerability is present.
7.2.2 If any database error messages were returned, investigate their meaning. Use the section ‚ÄúSQL Syntax and Error Reference‚Äù in [Chapter 9: Attacking Data Stores] to help interpret error messages on some common database platforms.
7.2.3 If submitting a single quotation mark in the parameter causes an error or other anomalous behavior, submit two single quotation marks. If this input causes the error or anomalous behavior to disappear, the application is probably vulnerable to SQL injection.
7.2.4 Try using common SQL string concatenator functions to construct a string that is equivalent to some benign input. If this causes the same response as the original benign input, the application is probably vulnerable. For example, if the original input is the expression FOO, you can perform
this test using the following items (in the third example, note the space between the two quotes):</p>
<pre tabindex="0"><code>‚Äò||‚ÄôFOO
‚Äò+‚ÄôFOO
‚Äò ‚ÄòFOO
=======
As always, be sure to URL-encode characters such as + and space that 
have special meaning within HTTP requests.
</code></pre><p>7.2.5 If the original input is numeric, try using a mathematical expression that is equivalent to the original value. For example, if the original value was 2, try submitting 1+1 or 3‚Äì1. If the application responds in the same way, it may be vulnerable, particularly if the value of the numeric expression
has a systematic effect on the application‚Äôs behavior.
7.2.6 If the preceding test is successful, you can gain further assurance that a SQL injection vulnerability is involved by using SQL-specific mathematical expressions to construct a particular value. If the application‚Äôs logic can be systematically manipulated in this way, it is almost certainly vulnerable to SQL injection. For example, both of the following items are equivalent to the number 2: <code>67-ASCII(‚ÄòA‚Äô)</code>    <code>51-ASCII(1)</code>
7.2.7 If either of the fuzz test cases using the <code>waitfor</code> command resulted in an abnormal time delay before the application responded, this is a strong indicator that the database type is MS-SQL and the application is vulnerable to SQL injection. Repeat the test manually, specifying different values in the <code>waitfor</code> parameter, and determine whether the time taken to respond varies systematically with this value. Note that your attack payload may be inserted into more than one SQL query, so the time delay observed may be a fixed multiple of the value specified.
7.2.8 If the application is vulnerable to SQL injection, consider what kinds of attacks are feasible and likely to help you achieve your objectives. Refer to [Chapter 9: Attacking Data Stores] for the detailed steps needed to carry out any of the following attacks:</p>
<ul>
<li>Modify the conditions within a <code>WHERE</code> clause to change the application‚Äôs logic (for example, by injecting or 1=1&ndash; to bypass a login).</li>
<li>Use the <code>UNION</code> operator to inject an arbitrary <code>SELECT</code> query and combine the results with those of the application‚Äôs original query.</li>
<li>Fingerprint the database type using database-specific SQL syntax.</li>
<li>If the database type is MS-SQL and the application returns ODBC error messages in its responses, leverage these to enumerate the database structure and retrieve arbitrary data.</li>
<li>If you cannot find a way to directly retrieve the results of an arbitrary injected query, use the following advanced techniques to extract data:
<ul>
<li>Retrieve string data in numeric form, one byte at a time.</li>
<li>Use an out-of-band channel.</li>
</ul>
</li>
<li>If you can cause different application responses based on a single arbitrary condition, use Absinthe to extract arbitrary data one bit at a time.</li>
<li>If you can trigger time delays based on a single arbitrary condition, exploit these to retrieve data one bit at a time.</li>
<li>If the application is blocking certain characters or expressions that you require to perform a particular attack, try the various bypass techniques described in [Chapter 9: Attacking Data Stores] to circumvent the input filter.</li>
<li>If possible, escalate the attack against the database and the underlying server by leveraging any vulnerabilities or powerful functions within the database.</li>
</ul>
<h2 id="73-test-for-xss-and-other-response-injection">7.3 Test for XSS and Other Response Injection</h2>
<h3 id="731-identify-reflected-request-parameters">7.3.1 Identify Reflected Request Parameters</h3>
<p>7.3.1.1 Sort the results of your fuzz testing by clicking the Payload Grep column, and identify any matches corresponding to the XSS payloads listed in step 7.1.3 These are cases where the XSS test strings were returned unmodified within the application‚Äôs responses.</p>
<p>7.3.1.2 For each of these cases, review the application‚Äôs response to find the location of the supplied input. If this appears within the response body, test for XSS vulnerabilities. If the input appears within any HTTP header, test for header injection vulnerabilities. If it is used in the Location header of a 302 response, or if it is used to specify a redirect in some other way, test for redirection vulnerabilities. Note that the same input might be copied into multiple locations within the response, and that more than one type of reflected vulnerability might be present.</p>
<h3 id="732-test-for-reflected-xss">7.3.2 Test for Reflected XSS</h3>
<p>7.3.2.1 For each place within the response body where the value of the request parameter appears, review the surrounding HTML to identify possible ways of crafting your input to cause execution of arbitrary JavaScript. For example, you can inject <code>&lt;script&gt;</code> tags, inject into an existing script, or place a crafted value into a tag attribute.
7.3.2.2 Use the different methods of beating signature-based filters described in
[Chapter 12: Attacking Users: Cross-Site Scripting] as a reference for the different ways in which crafted input can be used to cause execution of JavaScript.
7.3.2.3 Try submitting various possible exploits to the application, and monitor
its responses to determine whether any filtering or sanitization of input is being performed. If your attack string is returned unmodified, use a browser to verify conclusively that you have succeeded in executing arbitrary JavaScript (for example, by generating an alert dialog).</p>
<p>7.3.2.4 If you find that the application is blocking input containing certain characters or expressions you need to use, or is HTML-encoding certain characters, try the various filter bypasses described in [Chapter 12: Attacking Users: Cross-Site Scripting].</p>
<p>7.3.2.5 If you find an XSS vulnerability in a POST request, this can still be exploited via a malicious website that contains a form with the required parameters and a script to automatically submit the form. Nevertheless, a wider range of attack delivery mechanisms is available if the exploit
can be delivered via a GET request. Try submitting the same parameters in a GET request, and see if the attack still succeeds. You can use the Change Request Method action in Burp Proxy to convert the request for you.</p>
<h3 id="733-test-for-http-header-injection">7.3.3 Test for HTTP Header Injection</h3>
<p>7.3.3.1 For each place within the response headers where the value of the request parameter appears, verify whether the application accepts data containing URL-encoded carriage-return (%0d) and line-feed (%0a) characters and whether these are returned <code>unsanitized</code> in its response. (Note that you are looking for the actual newline characters themselves to appear in the server‚Äôs response, not their URL-encoded equivalents.)
7.3.3.2 If a new line appears in the server‚Äôs response headers when you supply crafted input, the application is vulnerable to HTTP header injection. This can be leveraged to perform various attacks, as described in [Chapter 13: Attacking Users: Other Techniques].
7.3.3.3 If you find that only one of the two newline characters gets returned in the server‚Äôs responses, it may still be possible to craft a working exploit, depending on the context and the target user‚Äôs browser.
7.3.3.4 If you find that the application blocks input containing newline characters, or sanitizes those characters in its response, try the following items of input to test the filter‚Äôs effectiveness:</p>
<pre tabindex="0"><code>foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar
</code></pre><h3 id="734-test-for-open-redirection">7.3.4 Test for Open Redirection</h3>
<p>7.3.4.1 If the reflected input is used to specify the target of a redirect of some kind, test whether it is possible to supply crafted input that results in an arbitrary redirect to an external website. If so, this behavior can be exploited to lend credibility to a <code>phishing-style</code> attack.</p>
<p>7.3.4.2 If the application ordinarily transmits an absolute URL as the parameter‚Äôs value, modify the domain name within the URL, and test whether the application redirects you to the different domain.
7.3.4.3 If the parameter normally contains a relative URL, modify this into an absolute URL for a different domain, and test whether the application redirects you to this domain.
7.3.4.4 If the application carries out some validation on the parameter before performing the redirect, in an effort to prevent external redirection, this is often vulnerable to bypasses. Try the various attacks described in [Chapter 13: Attacking Users: Other Techniques] to test the robustness of the filters.</p>
<h3 id="735-test-for-stored-attacks">7.3.5 Test for Stored Attacks</h3>
<p>7.3.5.1 If the application stores items of user-supplied input and later displays these on-screen, after you have fuzzed the entire application you may observe some of your attack strings being returned in responses to requests that did not themselves contain those strings. Note any instances where this occurs, and identify the original entry point for the data that is being stored.
7.3.5.2 In some cases, user-supplied data is stored successfully only if you complete a multistage process, which does not occur in <code>basic fuzz testing</code>. If your application mapping exercises identified any functionality of this kind, manually walk through the relevant process and test the stored data for XSS vulnerabilities.
7.3.5.3 If you have sufficient access to test it, review closely any administrative functionality in which data originating from low-privileged users is ultimately rendered on-screen in the session of more privileged users. Any stored XSS vulnerabilities in functionality of this kind typically lead directly to privilege escalation.
7.3.5.4 Test every instance where user-supplied data is stored and displayed to users. Probe these for XSS and the other response injection attacks described previously.
7.3.5.5 If you find a vulnerability in which input supplied by one user is displayed to other users, determine the most effective attack payload with which you can achieve your objectives, such as <code>session hijacking</code> or <code>request forgery</code>. If the stored data is displayed only to the same user from whom it originated, try to find ways of chaining any other vulnerabilities you have discovered (such as broken access controls) to inject an attack into other users‚Äô sessions.</p>
<p>7.3.5.6 If the application allows upload and download of files, always probe this functionality for stored XSS attacks. If the application allows HTML, JAR, or text fi es, and does not validate or sanitize their contents, it is almost certainly vulnerable. If it allows JPEG files and does not validate that they contain valid images, it is probably vulnerable to attacks against Internet Explorer users. Test the application‚Äôs handling of each file type it supports, and confirm how browsers handle responses containing HTML instead of the normal content type.
7.3.5.7 In every location where data submitted by one user is displayed to other users but where the application‚Äôs filters prevent you from performing a stored XSS attack, review whether the application‚Äôs behavior leaves it vulnerable to on-site request forgery.</p>
<h2 id="74-test-for-os-command-injection">7.4 Test for OS Command Injection</h2>
<p>7.4.1 If any of the command injection attack strings listed in step 7.1.3 resulted in an abnormal time delay before the application responded, this is a strong indicator that the application is vulnerable to OS command injection. Repeat the test, manually specifying different values in the <code>-i</code> or <code>-n</code> parameter, and determine whether the time taken to respond varies systematically with this value.
7.4.2 Using whichever of the injection strings was found to be successful, try injecting a more interesting command (such as <code>ls</code> or <code>dir</code>), and determine whether you can retrieve the results of the command to your browser.
7.4.3 If you are unable to retrieve results directly, other options are open to you:</p>
<ul>
<li>You can attempt to open an out-of-band channel back to your computer. Try using TFTP to copy tools up to the server, using telnet or <code>netcat</code> to create a reverse shell back to your computer, and using the mail command to send command output via SMTP.</li>
<li>You can redirect the results of your commands to a file within the web root, which you can then retrieve directly using your browser. For example: <code>dir &gt; c:\inetpub\wwwroot\foo.txt</code></li>
</ul>
<p>7.4.4 If you find a way to inject commands and retrieve the results, you should determine your privilege level (by using <code>whoami</code> or a similar command, or attempting to write a harmless file to a protected directory). You may then seek to escalate privileges, gain backdoor access to sensitive
application data, or attack other hosts that can be reached from the compromised server.</p>
<p>7.4.5 If you believe that your input is being passed to an OS command of some kind, but the attack strings listed are unsuccessful, see if you can use the <code>&lt; or &gt;</code> character to direct the contents of a file to the command‚Äôs input or to direct the command‚Äôs output to a fi le. This may enable you
to read or write arbitrary file contents. If you know or can guess the actual command being executed, try injecting command-line parameters associated with that command to modify its behavior in useful ways (for example, by specifying an output file within the web root).
7.4.6 If you find that the application is escaping certain key characters you need to perform a command injection attack, try placing the escape character before each such character. If the application does not escape the escape character itself, this usually leads to a bypass of this defensive measure. If you find that whitespace characters are blocked or sanitized, you may be able to use <code>$IFS</code> in place of spaces on UNIX-based platforms.</p>
<h2 id="75-test-for-path-traversal">7.5 Test for Path Traversal</h2>
<p>7.5.1 For each fuzz test you have performed, review the results generated by the path traversal attack strings listed in step 7.1.3. You can click the top of the payload column in Burp Intruder to sort the results table by payload and group the results for these strings. For any cases where
an unusual error message or a response with an abnormal length was received, review the response manually to determine whether it contains the contents of the specified fi le or other evidence that an anomalous file operation occurred.
7.5.2 In your mapping of the application‚Äôs attack surface, you should have noted any functionality that specifically supports the reading and writing of files on the basis of user-supplied input. In addition to the general fuzzing of all parameters, you should manually test this functionality
very carefully to identify any path traversal vulnerabilities that exist.</p>
<p>7.5.3 Where a parameter appears to contain a filename, a portion of a filename, or a directory, modify the parameter‚Äôs existing value to insert an arbitrary subdirectory and a single traversal sequence. For example, if the application submits this parameter:<code>file=foo/file1.txt</code>
try submitting this value: <code>file=foo/bar/../file1.txt</code> If the application‚Äôs behavior is identical in the two cases, it may be vulnerable, and you should proceed to the next step. If the behavior is different, the application may be blocking, stripping, or sanitizing traversal sequences, resulting in an invalid file path. Try using the encoding and other attacks described in [Chapter 10: Attacking Back-End Components] in an attempt to bypass the filters.</p>
<p>7.5.4 If the preceding test of using traversal sequences within the base directory is successful, try using additional sequences to step above the base directory and access known files on the server‚Äôs operating system. If these attempts fail, the application may be imposing various filters or checks before file access is granted. You should probe further to understand the controls that are implemented and whether any bypasses exist.
7.5.5 The application may be checking the file extension being requested and allowing access to only certain kinds of fi les. Try using a null byte or newline attack together with a known accepted file extension in an attempt to bypass the filter. For example: <code>../../../../../boot.ini%00.jpg</code>
<code>../../../../../etc/passwd%0a.jpg</code>
7.5.6 The application may be checking that the user-supplied file path starts with a particular directory or stem. Try appending traversal sequences after a known accepted stem in an attempt to bypass the filter. For example:  <code>/images/../../../../../../../etc/passwd</code>
7.5.7 If these attacks are unsuccessful, try combining multiple bypasses, working initially entirely within the base directory in an attempt to understand the filters in place and the ways in which the application handles unexpected input.
7.5.8 If you succeed in gaining read access to arbitrary fi les on the server, attempt to retrieve any of the following files, which may enable you to escalate your attack:</p>
<ul>
<li>Password files for the operating system and application</li>
<li>Server and application configuration files, to discover other vulnerabilities or fine-tune a different attack</li>
<li>Include files that may contain database credentials</li>
<li>Data sources used by the application, such as MySQL database files or XML files</li>
<li>The source code to server-executable pages, to perform a code review in search of bugs
Application log files that may contain information such as usernames and session tokens.</li>
</ul>
<p>7.5.9 If you succeed in gaining write access to arbitrary fi les on the server, examine whether any of the following attacks are feasible in order to escalate your attack:</p>
<ul>
<li>Creating scripts in users‚Äô startup folders</li>
<li>Modifying files such as <code>in.ftpd</code> to execute arbitrary commands when a user next connects</li>
<li>Writing scripts to a web directory with execute permissions and calling them from your browser</li>
</ul>
<h2 id="76-test-for-script-injection">7.6 Test for Script Injection</h2>
<p>7.6.1 For each fuzz test you have performed, review the results for the string <code>111111</code> on its own (that is, not preceded by the rest of the test string). You can quickly identify these in Burp Intruder by Shift-clicking the heading for the 111111 Grep string to group all the results containing this string. Look for any that do not have a check in the Payload Grep column. Any cases identified are likely to be vulnerable to injection of scripting commands.
7.6.2 Review all the test cases that used script injection strings, and identify any containing scripting error messages that may indicate that your input is being executed but caused an error. These may need to be fi ne-tuned to perform successful script injection.
7.6.3 If the application appears to be vulnerable, verify this by injecting further commands specific to the scripting platform in use. For example, you can use attack payloads similar to those used when fuzzing for OS command injection:
<code>system(‚Äòping%20127.0.0.1‚Äô)</code></p>
<h2 id="77-test-for-file-inclusion">7.7 Test for File Inclusion</h2>
<p>7.7.1 If you received any incoming HTTP connections from the target application‚Äôs infrastructure during your fuzzing, the application is almost certainly vulnerable to remote file inclusion. Repeat the relevant tests in a <code>single-threaded</code> and <code>time-throttled</code> way to determine exactly which parameters are causing the application to issue the HTTP requests.
7.7.2 Review the results of the file inclusion test cases, and identify any that caused an anomalous delay in the application‚Äôs response. In these cases, it may be that the application itself is vulnerable but that the resulting HTTP requests are timing out due to network-level filters.</p>
<p>7.7.3 If you find a remote fi le inclusion vulnerability, deploy a web server containing a malicious script specific to the language you are targeting, and use commands such as those used to test for script injection to verify that your script is being executed.</p>
<hr>
<h1 id="8-test-for-function-specific-input-vulns"><code>8 Test for Function-Specific Input VULNs</code></h1>
<h2 id="81-test-for-smtp-injection">8.1 Test for SMTP Injection</h2>
<p>8.1.1 For each request employed in e-mail‚Äìrelated functionality, submit each of the following test strings as each parameter in turn, inserting your own e-mail address at the relevant position. You can use <code>Burp Intruder</code> to automate this, as described in step 7.1 for general fuzzing. These test
strings already have special characters URL-encoded, so do not apply any additional encoding to them.</p>
<pre tabindex="0"><code>&lt;youremail&gt;%0aCc:&lt;youremail&gt;
&lt;youremail&gt;%0d%0aCc:&lt;youremail&gt;
&lt;youremail&gt;%0aBcc:&lt;youremail&gt;
&lt;youremail&gt;%0d%0aBcc:&lt;youremail&gt;
%0aDATA%0afoo%0a%2e%0aMAIL+FROM:+&lt;youremail&gt;%0aRCPT+TO:+&lt;youremail&gt;
%0aDATA%0aFrom:+&lt;youremail&gt;%0aTo:+&lt;youremail&gt;%0aSubject:+test%0afoo %0a%2e%0a
%0d%0aDATA%0d%0afoo%0d%0a%2e%0d%0aMAIL+FROM:+&lt;youremail&gt;%0d%0aRCPT+TO:+
&lt;youremail&gt;%0d%0aDATA%0d%0aFrom:+&lt;youremail&gt;%0d%0aTo:+&lt;youremail&gt;
%0d%0aSubject:+test%0d%0afoo%0d%0a%2e%0d%0a
</code></pre><p>8.1.2 Review the results to identify any error messages the application returns. If these appear to relate to any problem in the e-mail function, investigate whether you need to fine-tune your input to exploit a vulnerability.
8.1.3 Monitor the e-mail address you specified to see if any e-mail messages are received.
8.1.4 Review closely the HTML form that generates the relevant request. It may contain clues regarding the server-side software being used. It may also contain a hidden or disabled field that is used to specify the To address of the e-mail, which you can modify directly.</p>
<h2 id="82-test-for-native-software-vulnerabilities">8.2 Test for Native Software Vulnerabilities</h2>
<h3 id="821-test-for-buffer-overflows">8.2.1 Test for Buffer Overflows</h3>
<p>8.2.1.1 For each item of data being targeted, submit a range of long strings with lengths somewhat longer than common buffer sizes. Target one item of data at a time to maximize the coverage of code paths in the application. You can use the character blocks payload source in Burp Intruder to
automatically generate payloads of various sizes. The following buffer sizes are suitable to test:
1100  4200  33000</p>
<p>8.2.1.2 Monitor the application‚Äôs responses to identify any anomalies. An uncontrolled overflow is almost certain to cause an exception in the application, although diagnosing the nature of the problem remotely may be difficult. Look for any of the following anomalies:</p>
<ul>
<li>An HTTP 500 status code or error message, where other malformed (but not overlong) input does not have the same effect</li>
<li>An informative message indicating that a failure occurred in some external, native code component</li>
<li>A partial or malformed response being received from the server</li>
<li>The TCP connection to the server closing abruptly without returning a response</li>
<li>The entire web application no longer responding</li>
<li>Unexpected data being returned by the application, possibly indicating that a string in memory has lost its null terminator</li>
</ul>
<h3 id="822-test-for-integer-vulnerabilities">8.2.2 Test for Integer Vulnerabilities</h3>
<p>8.2.2.1 When dealing with native code components, identify any integer-based data, particularly length indicators, which may be used to trigger integer vulnerabilities.
8.2.2.2 Within each targeted item, send suitable payloads designed to trigger any vulnerabilities. For each item of data being targeted, send a series of different values in turn, representing boundary cases for the signed and unsigned versions of different sizes of integer. For example:</p>
<ul>
<li>0x7f and 0x80 (127 and 128)</li>
<li>0xff and 0x100 (255 and 256)</li>
<li>0x7ffff and 0x8000 (32767 and 32768)</li>
<li>0xffff and 0x10000 (65535 and 65536)</li>
<li>0x7fffffff and 0x80000000 (2147483647 and 2147483648)</li>
<li>0xffffffff and 0x0 (4294967295 and 0)</li>
</ul>
<p>8.2.2.3 When the data being modified is represented in hexadecimal form, send both little-endian and big-endian versions of each test case, such as <code>ff7f</code> and <code>7fff</code>. If hexadecimal numbers are submitted in <code>ASCII form</code>, use the same case as the application itself uses for alphabetic characters to ensure that these are decoded correctly.
8.2.2.4 Monitor the application‚Äôs responses for anomalous events, as described in step 8.2.1.2.</p>
<h3 id="823-test-for-format-string-vulnerabilities">8.2.3 Test for Format String Vulnerabilities</h3>
<p>8.2.3.1 Targeting each parameter in turn, submit strings containing long sequences of different format specifiers. For example:
<code>%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n%n %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s %1!n!%2!n!%3!n!%4!n!%5!n!%6!n!%7!n!%8!n!%9!n!%10!n! etc... %1!s!%2!s!%3!s!%4!s!%5!s!%6!s!%7!s!%8!s!%9!s!%10!s! etc...</code>
Remember to URL-encode the % character as <code>%25</code>.
8.2.3.2 Monitor the application‚Äôs responses for anomalous events, as described in step 8.2.1.2.</p>
<h2 id="83-test-for-soap-injection">8.3 Test for SOAP Injection</h2>
<p>8.3.1 Target each parameter in turn that you suspect is being processed via a SOAP message. Submit a rogue XML closing tag, such as <code>&lt;/foo&gt;</code>. If no error occurs, your input is probably not being inserted into a SOAP message or is being sanitized in some way.
8.3.2 If an error was received, submit instead a valid opening and closing tag pair, such as <code>&lt;foo&gt;&lt;/foo&gt;</code>. If this causes the error to disappear, the application may be vulnerable.
8.3.3 If the item you submit is copied back into the application‚Äôs responses, submit the following two values in turn. If you find that either item is returned as the other, or as simply test, you can be confident that your input is being inserted into an XML-based message. <code>test &lt;foo/&gt;</code> <code>test&lt;foo&gt;&lt;/foo&gt;</code>
8.3.4 If the HTTP request contains several parameters that may be being placed into a SOAP message, try inserting the opening comment character <code>&lt;!-- into one parameter and the closing comment character !--&gt;</code> into another parameter. Then switch these (because you have no way
of knowing in which order the parameters appear). This can have the effect of commenting out a portion of the server‚Äôs SOAP message, which may change the application‚Äôs logic or result in a different error condition that may divulge information.</p>
<h2 id="84-test-for-ldap-injection">8.4 Test for LDAP Injection</h2>
<p>8.4.1 In any functionality where user-supplied data is used to retrieve information from a directory service, target each parameter in turn to test for potential injection into an LDAP query.
8.4.2 Submit the <code>*</code> character. If a large number of results are returned, this is a good indicator that you are dealing with an LDAP query.
8.4.3 Try entering a number of closing parentheses: <code>))))))))))</code>
This input invalidates the query syntax, so if an error or other anomalous behavior results, the application may be vulnerable (although many other application functions and injection situations may behave in the same way).
8.4.4 Try entering various expressions designed to interfere with different types of queries, and see if these allow you to influence the results being returned. The <code>cn</code> attribute is supported by all LDAP implementations and is useful if you do not know any details about the directory you are querying:
<code>)(cn=* *))(|(cn=* *))%00</code>
8.4.5 Try adding extra attributes to the end of your input, using commas to separate each item. Test each attribute in turn. An error indicates that the attribute is not valid in the present context. The following attributes are commonly used in directories queried by LDAP:</p>
<pre tabindex="0"><code>cn
c
mail
givenname
o
ou
dc
l
uid
objectclass
postaladdress
dn
sn
</code></pre><h2 id="85-test-for-xpath-injection">8.5 Test for XPath Injection</h2>
<p>8.5.1 Try submitting the following values, and determine whether they result
n different application behavior without causing an error:
<code>‚Äò or count(parent::*[position()=1])=0 or ‚Äòa‚Äô=‚Äôb ‚Äò or count(parent::*[position()=1])&gt;0 or ‚Äòa‚Äô=‚Äôb</code>
8.5.2 If the parameter is numeric, also try the following test strings:</p>
<p><code>1 or count(parent::*[position()=1])=0</code> <code>1 or count(parent::*[position()=1])&gt;0</code>
8.5.3 If any of the preceding strings causes differential behavior within the application without causing an error, it is likely that you can extract arbitrary data by crafting test conditions to extract 1 byte of information at a time. Use a series of conditions with the following form to determine
the name of the current node‚Äôs parent: <code>substring(name(parent::*[position()=1]),1,1)=‚Äôa‚Äô</code></p>
<p>8.5.4 Having extracted the name of the parent node, use a series of conditions with the following form to extract all the data within the XML tree:
<code>substring(//parentnodename[position()=1]/child::node()[position()=1]/text(),1,1)=‚Äôa‚Äô</code></p>
<h2 id="86-test-for-back-end-request-injection">8.6 Test for Back-End Request Injection</h2>
<p>8.6.1 Locate any instance where an internal server name or IP address is specified in a parameter. Submit an arbitrary server and port, and monitor the application for a timeout. Also submit localhost, and finally your own IP address, monitoring for incoming connections on the port specified.
8.6.2 Target a request parameter that returns a specific page for a specific value, and try to append a new injected parameter using various syntax, including the following:
<code>%26foo%3dbar (URL-encoded &amp;foo=bar) %3bfoo%3dbar (URL-encoded ;foo=bar) %2526foo%253dbar (Double URL-encoded &amp;foo=bar)</code>
If the application behaves as if the original parameter were unmodified, there is a chance of HTTP parameter injection vulnerabilities. Attempt to attack the back-end request by injecting known parameter name/value pairs that may alter the back-end logic, as described in [Chapter 10: Attacking Back-End Components]</p>
<h2 id="87-test-for-xxe-injection">8.7 Test for XXE Injection</h2>
<p>8.7.1 If users are submitting XML to the server, an external entity injection attack may be possible. If a fi eld is known that is returned to the user, attempt to specify an external entity, as in the following example:</p>
<pre tabindex="0"><code>POST /search/128/AjaxSearch.ashx HTTP/1.1
Host: [mdsec.net](http://mdsec.net/)
Content-Type: text/xml; charset=UTF-8
Content-Length: 115
&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM ‚Äúfile:///windows/win.ini‚Äù &gt; ]&gt;
&lt;Search&gt;&lt;SearchTerm&gt;&amp;xxe;&lt;/SearchTerm&gt;&lt;/Search&gt;
</code></pre><p>If no known field can be found, specify an external entity of ‚Äú<a href="http://192.168.1.1:25/">http://192.168.1.1:25</a>‚Äù and monitor the page response time. If the page takes significantly longer to return or times out, it may be vulnerable.</p>
<hr>
<h1 id="9-test-for-logic-flaws"><code>9 Test for Logic Flaws</code></h1>
<h2 id="91-identify-the-key-attack-surface">9.1 Identify the Key Attack Surface</h2>
<p>9.1.1 Logic flaws can take a huge variety of forms and exist within any aspect of the application‚Äôs functionality. To ensure that probing for logic flaws is feasible, you should first narrow down the attack surface to a reasonable area for manual testing.
9.1.2 Review the results of your application mapping exercises, and identify any instances of the following features:</p>
<ul>
<li>Multistage processes</li>
<li>Critical security functions, such as login</li>
<li>Transitions across trust boundaries (for example, moving from being anonymous to being self-registered to being logged in)</li>
<li>Context-based functionality presented to a user</li>
<li>Checks and adjustments made to transaction prices or quantities</li>
</ul>
<h2 id="92-test-multistage-processes">9.2 Test Multistage Processes</h2>
<p>9.2.1 When a multistage process involves a defined sequence of requests, attempt to submit these requests out of the expected sequence. Try skipping certain stages, accessing a single stage more than once, and accessing earlier stages after later ones.
9.2.2 The sequence of stages may be accessed via a series of <code>GET</code> or <code>POST</code> requests for distinct URLs, or they may involve submitting different sets of parameters to the same URL. You may specify the stage being requested by submitting a function name or index within a request parameter. Be sure to understand fully the mechanisms that the application is employing to deliver access to distinct stages.</p>
<p>9.2.3 In addition to interfering with the sequence of steps, try taking parameters that are submitted at one stage of the process and submitting them at a different stage. If the relevant items of data are updated within the application‚Äôs state, you should investigate whether you can leverage this behavior to interfere with the application‚Äôs logic.
9.2.4 If a multistage process involves different users performing operations on the same set of data, try taking each parameter submitted by one user and submitting it as another. If they are accepted and processed as that user, explore the implications of this behavior, as described previously.
9.2.5 From the context of the functionality that is implemented, try to understand what assumptions the developers may have made and where the key attack surface lies. Try to identify ways of violating those assumptions to cause undesirable behavior within the application.
9.2.6 When multistage functions are accessed out of sequence, it is common to encounter a variety of anomalous conditions within the application, such as variables with null or uninitialized values, partially defined or inconsistent state, and other unpredictable behavior. Look for interesting error messages and debug output, which you can use to better understand the application‚Äôs internal workings and thereby fine-tune the current or a different attack.</p>
<h2 id="93-test-handling-of-incomplete-input">9.3 Test Handling of Incomplete Input</h2>
<p>9.3.1 For critical security functions within the application, which involve processing several items of user input and making a decision based on these, test the application‚Äôs resilience to requests containing incomplete input.
9.3.2 For each parameter in turn, remove both the name and value of the parameter from the request. Monitor the application‚Äôs responses for any divergence in its behavior and any error messages that shed light on the logic being performed.
9.3.3 If the request you are manipulating is part of a multistage process, follow the process through to completion, because the application may store data submitted in earlier stages within the session and then process this at a later stage.</p>
<h2 id="94-test-trust-boundaries">9.4 Test Trust Boundaries</h2>
<p>9.4.1 Probe how the application handles transitions between different types of trust of the user. Look for functionality where a user with a given trust status can accumulate an amount of state relating to his identity. For example, an anonymous user could provide personal information
during self-registration, or proceed through part of an account recovery process designed to establish his identity.
9.4.2 Try to find ways to make improper transitions across trust boundaries by accumulating relevant state in one area and then switching to a different area in a way that would not normally occur. For example, having completed part of an account recovery process, attempt to
switch to an authenticated user-specific page. Test whether the application assigns you an inappropriate level of trust when you transition in this way.
9.4.3 Try to determine whether you can harness any higher-privileged function directly or indirectly to access or infer information.</p>
<h2 id="95-test-transaction-logic">9.5 Test Transaction Logic</h2>
<p>9.5.1 In cases where the application imposes transaction limits, test the effects of submitting negative values. If these are accepted, it may be possible to beat the limits by making large transactions in the opposite direction.
9.5.2 Examine whether you can use a series of successive transactions to bring about a state that you can exploit for a useful purpose. For example, you may be able to perform several low-value transfers between accounts to accrue a large balance that the application‚Äôs logic was intended to
prevent.
9.5.3 If the application adjusts prices or other sensitive values based on criteria that are determined by user-controllable data or actions, first understand the algorithms used by the application, and the point within its logic where adjustments are made. Identify whether these adjustments are
made on a one-time basis, or whether they are revised in response to further actions performed by the user.
9.5.4 Try to find ways to manipulate the application‚Äôs behavior to cause it to get into a state where the adjustments it has applied do not correspond to the original criteria intended by its designers.</p>
<hr>
<h1 id="10-test-for-shared-hosting-vulnerabilities"><code>10 Test for Shared Hosting Vulnerabilities</code></h1>
<h2 id="101-test-segregation-in-shared-infrastructures">10.1 Test Segregation in Shared Infrastructures</h2>
<p>10.1.1 If the application is hosted in a shared infrastructure, examine the access mechanisms provided for customers of the shared environment to update and manage their content and functionality. Consider the following questions:</p>
<ul>
<li>Does the remote access facility use a secure protocol and suitably hardened infrastructure?</li>
<li>Can customers access files, data, and other resources that they do not legitimately need to access?</li>
<li>Can customers gain an interactive shell within the hosting environment and execute arbitrary commands?</li>
</ul>
<p>10.1.2 If a proprietary application is used to allow customers to configure and customize a shared environment, consider targeting this application as a way to compromise the environment itself and individual applications running within it.
10.1.3 If you can achieve command execution, SQL injection, or arbitrary file access within one application, investigate carefully whether this provides any way to escalate your attack to target other applications.</p>
<h2 id="102-test-segregation-between-asp-hosted-applications">10.2 Test Segregation Between ASP-Hosted Applications</h2>
<p>10.2.1 If the application belongs to an <code>ASP-hosted</code> service composed of a mix of shared and customized components, identify any shared components such as logging mechanisms, administrative functions, and database code components. Attempt to leverage these to compromise the shared portion of the application and thereby attack other individual
applications.</p>
<p>10.2.2 If a common database is used within any kind of shared environment, perform a comprehensive audit of the database configuration, patch level, table structure, and permissions using a database scanning tool such as <code>NGSSquirrel</code>. Any defects within the database security model may provide a way to escalate an attack from within one application to another.</p>
<hr>
<h1 id="11-test-for-application-server-vulnerabilities"><code>11 Test for Application Server Vulnerabilities</code></h1>
<h2 id="111-test-for-default-credentials">11.1 Test for Default Credentials</h2>
<p>11.1.1 Review the results of your application mapping exercises to identify the web server and other technologies in use that may contain accessible administrative interfaces.
11.1.2 Perform a <code>port scan</code> of the web server to identify any administrative interfaces running on a different port than the main target application.
11.1.3 For any identified interfaces, consult the manufacturer‚Äôs documentation and common default password listings to obtain default credentials.
11.1.4 If the default credentials do not work, use the steps listed in section 4 to attempt to guess valid credentials.
11.1.5 If you gain access to an administrative interface, review the available functionality and determine whether it can be used to further compromise the host and attack the main application.</p>
<h2 id="112-test-for-default-content">11.2 Test for Default Content</h2>
<p>11.2.1 Review the results of your <code>Nikto</code> scan (step 1.4.1) to identify any default content that may be present on the server but that is not an integral part of the application.
11.2.2 Use search engines and other resources such as <a href="http://www.exploit-db.com/">www.exploit-db.com</a> and <a href="http://www.osvdb.org/">www.osvdb.org</a> to identify default content and functionality included within the technologies you know to be in use. If feasible, carry out a local installation of these, and review them for any default functionality
that you may be able to leverage in your attack.
11.2.3 Examine the default content for any functionality or vulnerabilities that you may be able to leverage to attack the server or the application.</p>
<h2 id="113-test-for-dangerous-http-methods">11.3 Test for Dangerous HTTP Methods</h2>
<p>11.3.1 Use the <code>OPTIONS</code> method to list the HTTP methods that the server states are available. Note that different methods may be enabled in different directories. You can perform a vulnerability scan in <code>Paros</code> to perform this check.
11.3.2 Try each reported method manually to confirm whether it can in fact be used.
11.3.3 If you find that some <code>WebDAV</code> methods are enabled, use a <code>WebDAVenabled</code> client for further investigation, such as Microsoft FrontPage or the Open as Web Folder option in Internet Explorer.</p>
<h2 id="114-test-for-proxy-functionality">11.4 Test for Proxy Functionality</h2>
<p>11.4.1 Using both <code>GET</code> and <code>CONNECT</code> requests, try to use the web server as a proxy to connect to other servers on the Internet and retrieve content from them.
11.4.2 Using both <code>GET</code> and <code>CONNECT</code> requests, attempt to connect to different IP addresses and ports within the hosting infrastructure.
11.4.3 Using both <code>GET</code> and <code>CONNECT</code> requests, attempt to connect to common port numbers on the web server itself by specifying <code>127.0.0.1</code> as the target host in the request.</p>
<h2 id="115-test-for-virtual-hosting-misconfiguration">11.5 Test for Virtual Hosting Misconfiguration</h2>
<p>11.5.1 Submit GET requests to the root directory using the following:</p>
<ul>
<li>The correct Host header</li>
<li>A bogus <code>Host</code> header</li>
<li>The server‚Äôs IP address in the Host header</li>
<li>No Host header (use HTTP/1.0 only)</li>
</ul>
<p>11.5.2 Compare the responses to these requests. A common result is that directory listings are obtained when the server‚Äôs IP address is used in the Host header. You may also find that different default content is accessible.
11.5.3 If you observe different behavior, repeat the application mapping exercises described in section 1 using the hostname that generated different results. Be sure to perform a <code>Nikto</code> scan using the <code>-vhost</code> option to identify any default content that may have been overlooked during initial application mapping.</p>
<h2 id="116-test-for-web-server-software-bugs">11.6 Test for Web Server Software Bugs</h2>
<p>11.6.1 Run Nessus and any other similar scanners you have available to identify any known vulnerabilities in the web server software you are attacking.
11.6.2 Review resources such as Security Focus, <code>Bugtraq</code>, and Full Disclosure to find details of any recently discovered vulnerabilities that may not have been fixed on your target.
11.6.3 If the application was developed by a third party, investigate whether it ships with its own web server (often an open source server). If it does, investigate this for any vulnerabilities. Be aware that in this case, the server‚Äôs standard banner may have been modified.
11.6.4 If possible, consider performing a local installation of the software you are attacking, and carry out your own testing to find new vulnerabilities that have not been discovered or widely circulated.</p>
<h2 id="117-test-for-web-application-firewalling">11.7 Test for Web Application Firewalling</h2>
<p>11.7.1 Submit an arbitrary parameter name to the application with a clear attack payload in the value, ideally somewhere the application includes the name and/or value in the response. If the application blocks the attack, this is likely to be due to an external defense.
11.7.2 If a variable can be submitted that is returned in a server response, submit a range of fuzz strings and encoded variants to identify the behavior of the application defenses to user input.
11.7.3 Confirm this behavior by performing the same attacks on variables within the application.
11.7.4 For all fuzzing strings and requests, use payload strings that are unlikely to exist in a standard signature database. Although giving examples of these is by definition impossible, avoid using <code>/etc/passwd</code> or <code>/windows/system32/config/sam</code> as payloads for file retrieval. Also avoid using
terms such as <code>&lt;script&gt;</code> in an XSS attack and using <code>alert()</code> or <code>xss</code> as XSS payloads.
11.7.5 If a particular request is blocked, try submitting the same parameter in a different location or context. For instance, submit the same parameter in the URL in a GET request, within the body of a POST request, and within the URL in a POST request.
11.7.6 On ASP.NET, also try submitting the parameter as a cookie. The API <code>Request.Params[‚Äúfoo‚Äù]</code> will retrieve the value of a cookie named foo if the parameter foo is not found in the query string or message body.
11.7.7 Review all the other methods of introducing user input provided in [Chapter 4: Mapping the Application], picking any that are not protected.
11.7.8 Determine locations where user input is (or can be) submitted in a nonstandard format such as serialization or encoding. If none is available, build the attack string by concatenation and/or by spanning it across multiple variables. (Note that if the target is ASP.NET, you may be able
to use HPP to concatenate the attack using multiple specifications of the same variable.)</p>
<hr>
<h1 id="12-miscellaneous-checks"><code>12 Miscellaneous Checks</code></h1>
<h2 id="121-check-for-dom-based-attacks">12.1 Check for DOM-Based Attacks</h2>
<p>12.1.1 Perform a brief code review of every piece of JavaScript received from the application. Identify any XSS or redirection vulnerabilities that can be triggered by using a crafted URL to introduce malicious data into the DOM of the relevant page. Include all standalone JavaScript files and scripts contained within HTML pages (both static and dynamically generated).</p>
<p>12.1.2 Identify all uses of the following APIs, which may be used to access DOM data that can be controlled via a crafted URL:
<code>document.location document.URL document.URLUnencoded document.referrer window.location</code>
12.1.3 Trace the relevant data through the code to identify what actions are performed with it. If the data (or a manipulated form of it) is passed to one of the following APIs, the application may be vulnerable to XSS:
<code>document.write() document.writeln() document.body.innerHtml eval() window.execScript() window.setInterval() window.setTimeout()</code>
12.1.4 If the data is passed to one of the following APIs, the application may be vulnerable to a redirection attack:
<code>document.location document.URL document.open() window.location.href window.navigate() window.open()</code></p>
<h2 id="122-check-for-local-privacy-vulnerabilities">12.2 Check for Local Privacy Vulnerabilities</h2>
<p>12.2.1 Review the logs created by your intercepting proxy to identify all the <code>Set-Cookie</code> directives received from the application during your testing. If any of these contains an expires attribute with a date that is in the future, the cookie will be stored by users‚Äô browsers until that date. Review the contents of any persistent cookies for sensitive data.
12.2.2 If a persistent cookie is set that contains any sensitive data, a local attacker may be able to capture this data. Even if the data is encrypted, an attacker who captures it will be able to resubmit the cookie to the application and gain access to any data or functionality that this allows.
12.2.3 If any application pages containing sensitive data are accessed over <code>HTTP</code>, look for any cache directives within the server‚Äôs responses. If any of the following directives do not exist (either within the HTTP headers or within HTML metatags), the page concerned may be cached by one
or more browsers:
<code>Expires: 0 Cache-control: no-cache Pragma: no-cache</code>
12.2.4 Identify any instances within the application in which sensitive data is transmitted via a URL parameter. If any cases exist, examine the browser history to verify that this data has been stored there.
12.2.5 For all forms that are used to capture sensitive data from the user (such as credit card details), review the form‚Äôs HTML source. If the attribute <code>autocomplete=off</code> is not set, within either the form tag or the tag for the individual input field, data entered is stored within browsers that support autocomplete, provided that the user has not disabled this feature.
12.2.6 Check for technology-specific local storage.
12.2.6.1 Check for Flash local objects using the <code>BetterPrivacy</code> plug-in for Firefox.
12.2.6.2 Check any Silverlight isolated storage in this directory: <code>C:\Users{username}\AppData\LocalLow\Microsoft\Silverlight\</code>
12.2.6.3 Check any use of HTML5 local storage.</p>
<h2 id="123-check-for-weak-ssl-ciphers">12.3 Check for Weak SSL Ciphers</h2>
<p>12.3.1 If the application uses SSL for any of its communications, use the tool <code>THCSSLCheck</code> to list the ciphers and protocols supported.
12.3.2 If any weak or obsolete ciphers and protocols are supported, a suitably positioned attacker may be able to perform an attack to downgrade or decipher the SSL communications of an application user, gaining access to his sensitive data.
12.3.3 Some web servers advertise certain weak ciphers and protocols as supported but refuse to actually complete a handshake using these if a client requests them. This can lead to false positives when you use the <code>THCSSLCheck</code> tool. You can use the Opera browser to attempt to perform a complete handshake using specified weak protocols to confirm whether these can actually be used to access the application.</p>
<h2 id="124-check-same-origin-policy-configuration">12.4 Check Same-Origin Policy Configuration</h2>
<p>12.4.1 Check for the <code>/crossdomain.xml</code> file. If the application allows unrestricted access (by specifying <code>&lt;allow-access-from domain=‚Äù*‚Äù /&gt;</code>), Flash object from any other site can perform two-way interaction, riding on the sessions of application users. This would allow all data to be retrieved, and any user actions to be performed, by any other domain.
12.4.2 Check for the /clientaccesspolicy.xml fi le. Similar to Flash, if the <code>&lt;cross-domain-access&gt;</code> configuration is too permissive, other sites can perform two-way interaction with the site under assessment.
12.4.3 Test an application‚Äôs handling of cross-domain requests using <code>XMLHttpRequest</code> by adding an Origin header specifying a different domain and examining any Access-Control headers that are returned. The security implications of allowing two-way access from any domain, or from specified other domains, are the same as those described for the Flash cross-domain policy.</p>
<hr>
<h1 id="13-follow-up-any-information-leakage">13 Follow Up Any Information Leakage</h1>
<p>13.1 In all your probing of the target application, monitor its responses for error messages that may contain useful information about the error‚Äôs cause, the technologies in use, and the application‚Äôs internal structure and functionality.
13.2 If you receive any unusual error messages, investigate these using standard search engines. You can use various advanced search features to narrow down your results. For example:
<code>‚Äùunable to retrieve‚Äù filetype:php</code>
13.3 Review the search results, looking both for any discussion about the error message and for any other websites in which the same message has appeared. Other applications may produce the same message in a more verbose context, enabling you to better understand what kind of conditions
give rise to the error. Use the search engine cache to retrieve examples of error messages that no longer appear within the live application.
13.4 Use Google code search to locate any publicly available code that may be responsible for a particular error message. Search for snippets of error messages that may be hard-coded into the application‚Äôs source code. You can also use various advanced search features to specify the code
language and other details, if these are known. For example:
<code>unable\ to\ retrieve lang:php package:mail</code>
13.5 If you receive error messages with stack traces containing the names of library and third-party code components, search for these names on both types of search engine.</p>
<p>Made with ‚ù§Ô∏è By <a href="https://www.twitter.com/sl4x0">@sl4x0</a></p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
